# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import json
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
import warnings
import os
import sys

warnings.filterwarnings("ignore")

# Load JSON data
data_path = "data/input.json"
with open(data_path, "r", encoding="utf-8") as f:
    raw = json.load(f)

# Explore structure: could be list of dicts or dict of lists
if isinstance(raw, list):
    df = pd.DataFrame(raw)
elif isinstance(raw, dict):
    # Could be a single record, or dict with a key containing list
    # Try to find a list-valued key
    list_keys = [k for k, v in raw.items() if isinstance(v, list)]
    if list_keys:
        # Use the longest list
        best_key = max(list_keys, key=lambda k: len(raw[k]))
        entries = raw[best_key]
        if len(entries) > 0 and isinstance(entries[0], dict):
            df = pd.DataFrame(entries)
        else:
            df = pd.DataFrame(raw)
    else:
        df = pd.DataFrame([raw])
else:
    df = pd.DataFrame(raw)

# Normalize column names
df.columns = [str(c).strip() for c in df.columns]
df = df[[c for c in df.columns if not c.startswith("Unnamed")]]

# Identify text and target columns
# For multi-turn intent classification, we expect conversation text and intent labels
# Try to find conversation/text column and intent/label column

def find_col(df, candidates):
    cols_lower = {c.lower(): c for c in df.columns}
    for cand in candidates:
        if cand.lower() in cols_lower:
            return cols_lower[cand.lower()]
    return None

# Look for text-like columns
text_candidates = ["conversation", "text", "message", "messages", "input", "utterance",
                   "turns", "dialog", "dialogue", "content", "query", "question"]
target_candidates = ["intent", "label", "class", "category", "prediction", "target",
                     "predicted_intent", "true_intent", "ground_truth"]

text_col = find_col(df, text_candidates)
target_col = find_col(df, target_candidates)

# If conversations are stored as list of messages, flatten them
def flatten_conversation(val):
    if isinstance(val, list):
        parts = []
        for item in val:
            if isinstance(item, dict):
                # Try to extract text from dict
                for k in ["text", "message", "content", "body", "utterance"]:
                    if k in item:
                        speaker = item.get("sender", item.get("role", item.get("from", "")))
                        parts.append(f"{speaker}: {item[k]}" if speaker else str(item[k]))
                        break
                else:
                    parts.append(str(item))
            else:
                parts.append(str(item))
        return " ".join(parts)
    elif isinstance(val, dict):
        return str(val)
    else:
        return str(val)

# If no obvious text column, try to build one from available columns
if text_col is None:
    # Check if any column contains lists (conversation turns)
    for c in df.columns:
        sample = df[c].dropna().iloc[0] if len(df[c].dropna()) > 0 else None
        if isinstance(sample, (list, dict)):
            text_col = c
            break
    # If still none, try to concatenate all string columns except target
    if text_col is None:
        str_cols = [c for c in df.columns if df[c].dtype == object and c != target_col]
        if str_cols: