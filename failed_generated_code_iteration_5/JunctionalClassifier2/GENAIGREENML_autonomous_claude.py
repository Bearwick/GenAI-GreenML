# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pickle
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score
import warnings
import sys
import os

warnings.filterwarnings("ignore")

# Load the pickle file
dataset_path = "dict.pickle"

with open(dataset_path, "rb") as f:
    data = pickle.load(f, encoding="latin1")

# Inspect what we loaded
if isinstance(data, dict):
    # Try to convert dict to DataFrame
    # The dict might have various structures; handle common cases
    if all(isinstance(v, (list, np.ndarray)) for v in data.values()):
        df = pd.DataFrame(data)
    elif all(isinstance(v, dict) for v in data.values()):
        df = pd.DataFrame(data).T
    elif all(isinstance(v, pd.DataFrame) for v in data.values()):
        df = pd.concat(data.values(), ignore_index=True)
    else:
        # Try direct DataFrame construction
        try:
            df = pd.DataFrame(data)
        except Exception:
            # If dict has scalar values, wrap in list
            try:
                df = pd.DataFrame({k: [v] if not hasattr(v, '__len__') or isinstance(v, str) else v for k, v in data.items()})
            except Exception:
                # Last resort: treat keys as rows
                df = pd.DataFrame(list(data.items()), columns=["key", "value"])
elif isinstance(data, pd.DataFrame):
    df = data
elif isinstance(data, (list, np.ndarray)):
    df = pd.DataFrame(data)
else:
    # Try converting directly
    df = pd.DataFrame(data)

# Strip and normalize column names
df.columns = [str(c).strip() for c in df.columns]
df.columns = [' '.join(c.split()) for c in df.columns]
# Drop unnamed columns
df = df[[c for c in df.columns if not c.lower().startswith('unnamed')]]

assert df.shape[0] > 0, "Dataset is empty after loading"

# Based on README context: classification of junctional features from retina blood vessels
# Labels are -1 (remodelling), 0 (mixed/uncertainty), 1 (inactive)
# Try to identify target column

# Heuristic: find a column that looks like a label/target
# Prefer columns named 'label', 'class', 'target', 'y', or columns with few unique values
target_col = None
feature_cols = []

# First check for common target names
for candidate in ['label', 'Label', 'class', 'Class', 'target', 'Target', 'y', 'Y', 'category', 'Category', 'output', 'Output']:
    if candidate in df.columns:
        target_col = candidate
        break

if target_col is None:
    # Look for a column with values in {-1, 0, 1} or very few unique values
    for c in df.columns:
        col_data = df[c]
        try:
            col_numeric = pd.to_numeric(col_data, errors='coerce').dropna()
            unique_vals = set(col_numeric.unique())
            if unique_vals.issubset({-1, 0, 1, -1.0, 0.0, 1.0}) and len(unique_vals) >= 2:
                target_col = c
                break
        except Exception:
            continue

if target_col is None:
    # Pick the column with the fewest unique values (likely categorical target)
    min_unique = float('inf')
    for c in df.columns:
        nunique = df[c].nunique()
        if 2 <= nunique <= 20:
            if nunique < min_unique:
                min_unique = nunique
                target_col = c

if target_col is None:
    #