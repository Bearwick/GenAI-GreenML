# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# --- Robust CSV Loading ---
DATASET_PATH = "heart.csv"

try:
    df = pd.read_csv(DATASET_PATH)
except Exception:
    df = pd.DataFrame()

# Check if parsing produced a single column (possible separator issue)
if df.shape[1] <= 1:
    try:
        df = pd.read_csv(DATASET_PATH, sep=';', decimal=',')
    except Exception:
        pass

# If still single column, try whitespace separator (header line looks space-separated)
if df.shape[1] <= 1:
    try:
        df = pd.read_csv(DATASET_PATH, sep=r'\s+')
    except Exception:
        pass

# --- Column Name Normalization ---
df.columns = [str(c).strip() for c in df.columns]
df.columns = [' '.join(c.split()) for c in df.columns]
# Drop unnamed columns
df = df[[c for c in df.columns if not c.lower().startswith('unnamed')]]

# --- Identify schema ---
# Based on DATASET_HEADERS and context: this is the UCI Heart Disease dataset.
# The headers line "70.0 1.0 4.0 130.0 322.0 0.0 2.0 109.0 0.0 2.4 2.0 3.0 3.0 2"
# suggests the CSV may have numeric headers (the first data row used as header).
# Standard UCI heart disease columns:
EXPECTED_COLS = ['age', 'sex', 'cp', 'trestbps', 'chol', 'fbs', 'restecg',
                 'thalach', 'exang', 'oldpeak', 'slope', 'ca', 'thal', 'target']

# If the number of columns matches expected, rename
if df.shape[1] == len(EXPECTED_COLS):
    # Check if headers look numeric (i.e., the first row was used as header)
    headers_look_numeric = True
    for c in df.columns:
        try:
            float(c)
        except (ValueError, TypeError):
            headers_look_numeric = False
            break

    if headers_look_numeric:
        # The actual header row is data; we need to recover it
        header_row = pd.DataFrame([df.columns.tolist()], columns=EXPECTED_COLS)
        df.columns = EXPECTED_COLS
        # Convert header_row values to match dtypes
        for col in EXPECTED_COLS:
            header_row[col] = pd.to_numeric(header_row[col], errors='coerce')
        df = pd.concat([header_row, df], ignore_index=True)
    else:
        # Headers are meaningful strings; check if they match expected or just use them
        # Map to expected if possible
        pass
elif df.shape[1] == 14:
    # Right number of columns, assign standard names
    headers_look_numeric = all(
        isinstance(c, (int, float)) or (isinstance(c, str) and c.replace('.', '', 1).replace('-', '', 1).isdigit())
        for c in df.columns
    )
    if headers_look_numeric:
        header_row = pd.DataFrame([df.columns.tolist()], columns=EXPECTED_COLS)
        df.columns = EXPECTED_COLS
        for col in EXPECTED_COLS:
            header_row[col] = pd.to_numeric(header_row[col], errors='coerce')
        df = pd.concat([header_row, df], ignore_index=True)

# --- Coerce all columns to numeric ---
for col in df.columns:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# --- Drop rows/cols that are all