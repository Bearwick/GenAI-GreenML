# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import pandas as pd
import numpy as np
from scipy.spatial.distance import cdist

def load_data(file_path):
    try:
        df = pd.read_csv(file_path)
        if df.shape[1] < 5:
            raise ValueError
    except Exception:
        df = pd.read_csv(file_path, sep=';', decimal=',')
    return df

def run_analysis():
    np.random.seed(42)
    
    df = load_data('iris.csv')
    
    data_values = df.values
    
    features = data_values[:, 2:4].astype(float)
    raw_labels = data_values[:, -1]
    
    label_map = {'setosa': 0, 'versicolor': 1, 'virginica': 2}
    y_true = np.array([label_map.get(l, l) for l in raw_labels], dtype=float)
    
    unique_labels = [0.0, 1.0, 2.0]
    centroids = np.array([features[y_true == i].mean(axis=0) for i in unique_labels])
    
    distances = cdist(features, centroids, metric='euclidean')
    y_pred = np.argmin(distances, axis=1)
    
    accuracy = np.mean(y_pred == y_true)
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    run_analysis()

# Optimization Summary
# - Eliminated matplotlib and all visualization overhead, reducing CPU/GPU cycles and memory footprint.
# - Optimized data loading by using pandas read_csv with fallback logic, which is more efficient than numpy.loadtxt for mixed types.
# - Reduced data movement by selecting only necessary features (petal_length, petal_width) early in the process.
# - Replaced manual label-replacement loops with a dictionary-based map for faster execution.
# - Streamlined centroid calculation using list comprehension and vectorized boolean indexing.
# - Removed redundant astype(float) calls and unnecessary intermediate array transformations.
# - Eliminated single-sample distance calculations and diagnostic prints that do not contribute to final accuracy.
# - Used scipy.spatial.distance.cdist to compute all distances in a single optimized C-call.