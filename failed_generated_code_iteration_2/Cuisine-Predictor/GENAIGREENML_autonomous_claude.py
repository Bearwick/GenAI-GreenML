# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
import json
import warnings
warnings.filterwarnings('ignore')

# Load JSON dataset
data = None
try:
    with open('train.json', 'r') as f:
        data = json.load(f)
except Exception:
    try:
        data = pd.read_json('train.json')
    except Exception:
        pass

if data is None:
    print("ACCURACY=0.000000")
    import sys
    sys.exit(0)

# Convert to DataFrame if needed
if isinstance(data, list):
    df = pd.DataFrame(data)
elif isinstance(data, dict):
    df = pd.DataFrame(data)
else:
    df = data.copy()

# Strip/normalize column names
df.columns = [str(c).strip() for c in df.columns]
df = df[[c for c in df.columns if not c.startswith('Unnamed')]]

# Identify target and features
# Expected schema: id, cuisine (target), ingredients (list of strings)
target_col = None
ingredients_col = None

for c in df.columns:
    cl = c.lower()
    if cl == 'cuisine':
        target_col = c
    if cl == 'ingredients':
        ingredients_col = c

# Fallback: if no cuisine column, try to find a string/categorical target
if target_col is None:
    for c in df.columns:
        if df[c].dtype == object and df[c].nunique() > 1 and df[c].nunique() < 1000:
            target_col = c
            break

if ingredients_col is None:
    # Try to find a column that contains lists
    for c in df.columns:
        if c == target_col:
            continue
        sample = df[c].dropna().iloc[0] if len(df[c].dropna()) > 0 else None
        if isinstance(sample, list):
            ingredients_col = c
            break

assert target_col is not None, "No target column found"
assert ingredients_col is not None, "No ingredients column found"
assert len(df) > 0, "Dataset is empty"

# Convert ingredients lists to space-joined strings for text vectorization
df['ingredients_text'] = df[ingredients_col].apply(
    lambda x: ' '.join([str(i).lower().strip() for i in x]) if isinstance(x, list) else str(x).lower()
)

# Encode target
le = LabelEncoder()
df['target_encoded'] = le.fit_transform(df[target_col].astype(str))

n_classes = df['target_encoded'].nunique()
assert n_classes >= 2, "Need at least 2 classes for classification"

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(
    df['ingredients_text'],
    df['target_encoded'],
    test_size=0.2,
    random_state=42,
    stratify=df['target_encoded']
)

assert len(X_train) > 0, "Training set is empty"
assert len(X_test) > 0, "Test set is empty"

# TF-IDF vectorization - lightweight text representation
# Using max_features to limit dimensionality for energy efficiency
tfidf = TfidfVectorizer(
    max_features=5000,
    sublinear_tf=True,
    ngram_range=(1, 1),
    token_pattern=r'(?u)\b\w+\b'
)

X_train_tfidf = tfidf.fit_transform(X_train)
X_test_tfidf = tfidf.transform(X_test)

# Logistic Regression - energy efficient, good for text classification
# Using saga solver for efficiency with sparse data, limited max_iter
model = Log