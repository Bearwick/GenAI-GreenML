# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import pandas as pd
import numpy as np
import os
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split

def load_robust(path):
    try:
        df = pd.read_csv(path)
        if df.shape[1] < 5:
            raise ValueError
    except:
        df = pd.read_csv(path, sep=';', decimal=',')
    return df

def main():
    train_path = "MNIST_train.csv"
    test_path = "MNIST_test.csv"
    
    if not os.path.exists(train_path):
        return

    train_df = load_robust(train_path)
    
    if os.path.exists(test_path):
        test_df = load_robust(test_path)
    else:
        train_df, test_df = train_test_split(train_df, test_size=0.2, random_state=42)

    label_col = train_df.columns[0]
    
    X_train = train_df.drop(columns=[label_col]).values.astype(np.uint8)
    y_train = train_df[label_col].values
    X_test = test_df.drop(columns=[label_col]).values.astype(np.uint8)
    y_test = test_df[label_col].values

    knn = KNeighborsClassifier(
        n_neighbors=7, 
        weights='distance', 
        algorithm='auto', 
        n_jobs=-1
    )
    
    knn.fit(X_train, y_train)
    accuracy = knn.score(X_test, y_test)

    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# 1. Replaced inefficient manual CSV parsing with pandas.read_csv for faster I/O and better memory management.
# 2. Used NumPy uint8 data types for pixel data to reduce memory footprint by 75% compared to standard 64-bit integers.
# 3. Replaced O(N*M) manual KNN loops with scikit-learn's optimized implementation, which uses KD-Trees or Ball-Trees to reduce search complexity to O(log N).
# 4. Vectorized Euclidean distance calculations using C-optimized backends, significantly reducing CPU cycles and energy per operation.
# 5. Enabled multi-core processing (n_jobs=-1) to decrease total runtime, allowing the system to return to an idle low-power state sooner (race-to-sleep principle).
# 6. Eliminated redundant list operations (del/append/max) used in the original neighbor tracking logic.
# 7. Automated header handling and data type conversion to prevent overhead from manual string-to-int parsing in Python loops.