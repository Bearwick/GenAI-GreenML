# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import pandas as pd
import numpy as np
import pickle
import os
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

def load_robust_csv(path):
    if not os.path.exists(path):
        return None
    try:
        df = pd.read_csv(path, engine='c')
        if df.shape[1] <= 1:
            df = pd.read_csv(path, sep=';', decimal=',', engine='c')
    except Exception:
        try:
            df = pd.read_csv(path, sep=';', decimal=',', engine='c')
        except Exception:
            return None
    return df.dropna(axis=1, how='all')

def run_pipeline():
    np.random.seed(42)
    mlp = MLPClassifier(hidden_layer_sizes=(30, 30, 30, 30), max_iter=1000, random_state=42)
    accuracy = 0.0

    df_train = load_robust_csv('14k.csv')
    if df_train is not None:
        data = df_train.to_numpy(dtype=np.float64)
        if data.size > 0:
            X = data[:, :-1]
            y = data[:, -1]
            y = np.where(y > 0, 1, np.where(y < 0, -1, 0))
            
            X_train, X_test, y_train, y_test = train_test_split(
                X, y, test_size=0.3, random_state=42
            )
            
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            mlp.fit(X_train_scaled, y_train)
            y_pred = mlp.predict(X_test_scaled)
            accuracy = accuracy_score(y_test, y_pred)

    if os.path.exists('dict.pickle'):
        try:
            with open('dict.pickle', 'rb') as f:
                mlp = pickle.load(f)
        except Exception:
            pass

    df_input = load_robust_csv('input.csv')
    if df_input is not None:
        p_feat = df_input.to_numpy(dtype=np.float64)
        if p_feat.size > 0:
            scaler_p = StandardScaler()
            p_feat_scaled = scaler_p.fit_transform(p_feat)
            prediction = mlp.predict(p_feat_scaled)
            print(prediction)

    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    run_pipeline()

# Optimization Summary
# 1. Replaced manual line-by-line CSV parsing with pandas.read_csv utilizing the C engine for significantly faster I/O.
# 2. Vectorized feature extraction and label transformation (using NumPy slicing and np.where) to eliminate inefficient Python loops.
# 3. Reduced memory overhead by avoiding redundant conversions between Python lists and NumPy arrays.
# 4. Eliminated unnecessary model re-saving to disk (saveModel) during the prediction phase to save energy and I/O cycles.
# 5. Consolidated preprocessing steps using fit_transform() to reduce computational redundancy.
# 6. Fixed random seeds for the MLP and data splitting to ensure deterministic behavior and reproducibility.
# 7. Removed unused dependencies (unittest, copy, csv) and modularized data loading for a lighter runtime footprint.
# 8. Implemented a robust data loading utility with fallback delimiters to handle varying CSV formats without manual intervention.