# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pickle
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.svm import LinearSVC
from sklearn.metrics import accuracy_score

# Load the pickle file
with open("dict.pickle", "rb") as f:
    data = pickle.load(f)

# Inspect what we got and convert to DataFrame
if isinstance(data, dict):
    # Could be a dict of arrays/lists, or a dict with specific keys like 'data', 'target'
    if 'data' in data and 'target' in data:
        X_raw = np.array(data['data'])
        y_raw = np.array(data['target'])
        if 'feature_names' in data:
            feature_names = list(data['feature_names'])
        else:
            feature_names = [f"f{i}" for i in range(X_raw.shape[1])]
        df = pd.DataFrame(X_raw, columns=feature_names)
        df['__target__'] = y_raw
        target_col = '__target__'
    else:
        # Try to build a DataFrame from the dict directly
        # Each key might be a column
        try:
            df = pd.DataFrame(data)
        except Exception:
            # Maybe dict of single values or nested structures
            # Try converting values
            keys = list(data.keys())
            vals = list(data.values())
            # Check if values are arrays of same length
            lengths = []
            for v in vals:
                if hasattr(v, '__len__') and not isinstance(v, str):
                    lengths.append(len(v))
                else:
                    lengths.append(1)
            if len(set(lengths)) == 1 and lengths[0] > 1:
                df = pd.DataFrame({k: v for k, v in zip(keys, vals)})
            else:
                # Last resort: try to make a single-row DataFrame
                df = pd.DataFrame({k: [v] for k, v in zip(keys, vals)})
        target_col = None
elif isinstance(data, pd.DataFrame):
    df = data
    target_col = None
elif isinstance(data, (list, np.ndarray)):
    arr = np.array(data)
    if arr.ndim == 2:
        df = pd.DataFrame(arr, columns=[f"f{i}" for i in range(arr.shape[1])])
    else:
        df = pd.DataFrame({'value': arr})
    target_col = None
else:
    # Try converting to DataFrame
    df = pd.DataFrame(data)
    target_col = None

# Clean column names
df.columns = [str(c).strip() for c in df.columns]
df.columns = [' '.join(c.split()) for c in df.columns]
# Drop unnamed columns
df = df[[c for c in df.columns if not c.lower().startswith('unnamed')]]

# If target_col not set, try to identify it
# Based on project context: target is a classification label (-1, 0, 1) for junctional classification
if target_col is None:
    # Look for likely target columns
    candidate_targets = []
    for c in df.columns:
        cl = c.lower()
        if any(kw in cl for kw in ['target', 'label', 'class', 'category', 'output', 'y']):
            candidate_targets.append(c)

    if candidate_targets:
        target_col = candidate_targets[0]
    else:
        # Pick last column as target (common convention)
        target_col = df.columns[-1]

# Separate features and target
feature_cols = [c for c in df.columns if c != target_col]

# Coerce all feature columns to numeric
for c in feature_cols:
    df[c] = pd.to_numeric(df[c], errors='coerce')

# Coerce target
df[target_col] = pd