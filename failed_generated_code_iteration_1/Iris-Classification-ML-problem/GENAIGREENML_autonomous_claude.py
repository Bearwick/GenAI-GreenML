# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
import warnings
warnings.filterwarnings("ignore")

SEED = 4096
np.random.seed(SEED)

file_path = 'iris.data'

# Robust CSV loading
df = None
try:
    df = pd.read_csv(file_path, header=None)
    if df.shape[1] < 2:
        df = pd.read_csv(file_path, header=None, sep=';', decimal=',')
except Exception:
    try:
        df = pd.read_csv(file_path, header=None, sep=';', decimal=',')
    except Exception:
        pass

if df is None or df.empty:
    try:
        df = pd.read_csv(file_path)
        if df.shape[1] < 2:
            df = pd.read_csv(file_path, sep=';', decimal=',')
    except Exception:
        pass

assert df is not None and not df.empty, "Failed to load dataset"

# Assign column names based on expected Iris schema (5 columns: 4 features + 1 class)
if df.shape[1] == 5:
    df.columns = ['SLength', 'SWidth', 'PLength', 'PWidth', 'class']
else:
    # Generic column names
    df.columns = [f'col_{i}' for i in range(df.shape[1])]

# Strip/normalize column names
df.columns = [str(c).strip() for c in df.columns]

# Drop 'Unnamed' columns
df = df[[c for c in df.columns if not c.startswith('Unnamed')]]

# Remove rows that are entirely NaN
df.dropna(how='all', inplace=True)

# Identify target column
target_col = None
if 'class' in df.columns:
    target_col = 'class'
else:
    # Try to find a categorical or string column as target; else use last column
    for c in reversed(df.columns.tolist()):
        if df[c].dtype == object:
            target_col = c
            break
    if target_col is None:
        target_col = df.columns[-1]

feature_cols = [c for c in df.columns if c != target_col]

# Coerce feature columns to numeric
for c in feature_cols:
    df[c] = pd.to_numeric(df[c], errors='coerce')

# Drop rows with NaN in features after coercion
df.dropna(subset=feature_cols, inplace=True)

# Remove non-numeric feature columns (if any remain object after coercion)
numeric_features = []
for c in feature_cols:
    if pd.api.types.is_numeric_dtype(df[c]):
        numeric_features.append(c)
feature_cols = numeric_features

assert len(feature_cols) > 0, "No numeric feature columns found"

# Handle target: encode if categorical/string
if df[target_col].dtype == object or df[target_col].dtype.name == 'category':
    le = LabelEncoder()
    df[target_col] = le.fit_transform(df[target_col].astype(str))
else:
    df[target_col] = pd.to_numeric(df[target_col], errors='coerce')
    df.dropna(subset=[target_col], inplace=True)
    df[target_col] = df[target_col].astype(int)

assert len(df) > 0, "Dataset empty after preprocessing"

X = df[list(feature_cols)].values.astype(np.float64)
y = df[target_col].values

# Replace inf with NaN then impute with column mean
X = np.where(np.isinf(X), np.nan, X)
col_means = np.nanmean(X