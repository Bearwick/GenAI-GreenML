# Generated by generate_llm_code.py
# LLM: claude
# Mode: assisted

import numpy as np
from sklearn.neighbors import KNeighborsClassifier
import pandas as pd

def load_data(filename):
    try:
        df = pd.read_csv(filename)
        if df.shape[1] < 2:
            df = pd.read_csv(filename, sep=';', decimal=',')
    except Exception:
        df = pd.read_csv(filename, sep=';', decimal=',')
    return df

def main():
    train_df = load_data("MNIST_train.csv")
    test_df = load_data("MNIST_test.csv")

    label_col = train_df.columns[0]

    y_train = train_df[label_col].values.astype(int)
    X_train = train_df.drop(columns=[label_col]).values.astype(np.float32)

    y_test = test_df[label_col].values.astype(int)
    X_test = test_df.drop(columns=[label_col]).values.astype(np.float32)

    k = 7
    knn = KNeighborsClassifier(
        n_neighbors=k,
        weights='distance',
        algorithm='ball_tree',
        metric='euclidean',
        n_jobs=-1
    )
    knn.fit(X_train, y_train)
    predictions = knn.predict(X_test)

    correct = np.sum(predictions == y_test)
    total = len(y_test)
    accuracy = (correct / total) * 100

    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# - Replaced manual Python-loop Euclidean distance and KNN with sklearn KNeighborsClassifier using ball_tree, drastically reducing compute time.
# - Used numpy float32 instead of float64 to halve memory footprint for pixel data.
# - Used n_jobs=-1 to parallelize neighbor search across CPU cores.
# - Removed all redundant intermediate lists (desiredClasses, computedClasses built via loop).
# - Removed manual CSV parsing with repeated int() casts; replaced with pandas read_csv with robust fallback.
# - Removed all prints, plots, and logging except the required accuracy output.
# - weights='distance' preserves the original 1/distance weighted voting behavior.
# - Eliminated redundant max() calls in the original KNN loop (called multiple times per iteration).
# - No artifacts saved; no interactive inputs; deterministic with fixed algorithm choice.