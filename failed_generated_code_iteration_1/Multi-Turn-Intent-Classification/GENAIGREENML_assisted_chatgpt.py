# Generated by generate_llm_code.py
# LLM: chatgpt
# Mode: assisted

import os
import json
import csv
import re
from typing import List, Dict, Any, Optional

import numpy as np
import torch
from transformers import pipeline


SEED = 42


def _set_reproducible(seed: int = SEED) -> None:
    np.random.seed(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(seed)
    try:
        torch.use_deterministic_algorithms(True)
    except Exception:
        pass


_PUNCT_RE = re.compile(r"[^\w\s]")
_SPACE_RE = re.compile(r"\s+")


def clean_and_lowercase(text: str) -> str:
    if not text:
        return ""
    cleaned = text.lower()
    cleaned = _PUNCT_RE.sub("", cleaned)
    cleaned = _SPACE_RE.sub(" ", cleaned)
    return cleaned.strip()


def create_conversation(messages: List[dict], max_messages: Optional[int] = None) -> str:
    if not messages:
        return ""
    if max_messages is not None and max_messages > 0 and len(messages) > max_messages:
        messages = messages[-max_messages:]

    parts = []
    for m in messages:
        sender = (m.get("sender") or "").capitalize()
        text = m.get("text") or ""
        parts.append(f"{sender}: {text}")
    return "\n".join(parts)


class IntentDetector:
    def __init__(
        self,
        intent_options: Optional[List[str]] = None,
        model_name: str = "cross-encoder/nli-distilroberta-base",
    ):
        self.intent_options = intent_options or [
            "Book Appointment",
            "Product Inquiry",
            "Pricing Negotiation",
            "Support Request",
            "Follow-Up",
        ]
        device = 0 if torch.cuda.is_available() else -1
        self.intent_pipeline = pipeline(
            task="zero-shot-classification",
            model=model_name,
            device=device,
        )

    def classify_intent(self, dialogue: str) -> Dict[str, str]:
        classification = self.intent_pipeline(dialogue, self.intent_options)
        top_intent = classification["labels"][0]
        explanation = (
            f"Based on the conversation, the customer is likely interested in '{top_intent.lower()}'."
        )
        return {"predicted_intent": top_intent, "rationale": explanation}


def _load_conversations(input_file: str) -> List[Dict[str, Any]]:
    with open(input_file, "r", encoding="utf-8") as infile:
        data = json.load(infile)
    return data if isinstance(data, list) else []


def predict_intents(
    input_file: str,
    json_output: str,
    csv_output: str,
    intent_model: IntentDetector,
) -> float:
    conversations = _load_conversations(input_file)

    os.makedirs(os.path.dirname(json_output) or ".", exist_ok=True)
    os.makedirs(os.path.dirname(csv_output) or ".", exist_ok=True)

    output_data: List[Dict[str, Any]] = []
    correct = 0
    total = 0

    for entry in conversations:
        conv_id = entry.get("conversation_id")
        formatted_text = create_conversation(entry.get("messages", []))
        intent_result = intent_model.classify_intent(formatted_text)

        predicted_intent = intent_result["predicted_intent"]
        output_data.append(
            {
                "conversation_id": conv_id,
                "predicted_intent": predicted_intent,
                "rationale": intent_result["rationale"],
            }
        )

        true_intent = entry.get("intent")
        if true_intent is not None:
            total += 1
            if str(true_intent) == str(predicted_intent):
                correct += 1

    with open(json_output, "w", encoding="utf-8") as json_file:
        json.dump(output_data, json_file, indent=2, ensure_ascii=False)

    with open(csv_output, "w", newline="", encoding="utf-8") as csv_file:
        fieldnames = ["conversation_id", "predicted_intent", "rationale"]
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(output_data)

    return (correct / total) if total else 0.0


def main() -> None:
    _set_reproducible(SEED)
    intent_model = IntentDetector()

    accuracy = predict_intents(
        input_file="data/input.json",
        json_output="data/output/predictions.json",
        csv_output="data/output/predictions.csv",
        intent_model=intent_model,
    )
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# - Removed unused imports (emoji, typing extras, os.makedirs at module import) to reduce startup overhead and memory.
# - Precompiled regular expressions to avoid recompiling patterns on each call and reduce CPU work.
# - Avoided creating intermediate lists in create_conversation beyond a single parts list and used simple loops for lower overhead.
# - Selected device explicitly for the Transformers pipeline to avoid unnecessary device probing work and ensure efficient execution.
# - Centralized reproducibility controls (fixed seeds + deterministic algorithms when available) for stable, repeatable results.
# - Streamlined I/O: loaded JSON once, wrote outputs once, ensured UTF-8 handling, and avoided any extra logging/printing.
# - Implemented accuracy computation only when ground-truth labels exist in input, avoiding extra work otherwise while preserving behavior.