# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

DATASET_PATH = "Iris.csv"
DATASET_HEADERS = ["Id", "SepalLengthCm", "SepalWidthCm", "PetalLengthCm", "PetalWidthCm", "Species"]

def _needs_fallback(df, expected_headers):
    if df.shape[1] <= 1:
        return True
    expected = set(expected_headers)
    return len(expected.intersection(df.columns)) == 0

def read_csv_robust(path, expected_headers):
    df = pd.read_csv(path)
    if _needs_fallback(df, expected_headers):
        df = pd.read_csv(path, sep=";", decimal=",")
    return df

def _get_id_column(df, expected_headers):
    for col in expected_headers:
        if col in df.columns and col.lower() == "id":
            return col
    return None

def _get_target_column(df, expected_headers):
    for col in reversed(expected_headers):
        if col in df.columns:
            return col
    return df.columns[-1]

def prepare_data(df, expected_headers):
    id_col = _get_id_column(df, expected_headers)
    if id_col:
        df = df.drop(columns=[id_col])
    target_col = _get_target_column(df, expected_headers)
    label_encoder = LabelEncoder()
    df[target_col] = label_encoder.fit_transform(df[target_col])
    y = df.pop(target_col)
    X = df
    return X, y

def train_and_evaluate(X, y, seed):
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=seed, stratify=y
    )
    model = RandomForestClassifier(n_estimators=100, random_state=seed, n_jobs=1)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    return accuracy_score(y_test, y_pred)

def main():
    seed = 42
    np.random.seed(seed)
    df = read_csv_robust(DATASET_PATH, DATASET_HEADERS)
    X, y = prepare_data(df, DATASET_HEADERS)
    accuracy = train_and_evaluate(X, y, seed)
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# Removed visualization and verbose reporting steps to avoid unnecessary computation and dependencies.
# Used in-place column removal and pop to reduce data copying and memory overhead.
# Implemented robust CSV parsing with fallback to prevent misread data without repeated processing.
# Derived schema from provided headers to avoid hardcoded column assumptions.
# Set fixed seeds and single-threaded training for reproducible and lower-overhead execution.