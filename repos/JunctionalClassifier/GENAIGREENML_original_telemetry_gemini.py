# Generated by generate_llm_code.py
# LLM: gemini
# Mode: original_telemetry

import csv
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPClassifier
from sklearn import metrics

features = []
labels = []

def make_csv(inpt):
    global features, labels
    first = True
    with open(inpt, newline='') as csvfile:
        reader = csv.reader(csvfile, delimiter=' ', quotechar='|')
        for row in reader:
            cols = row[0].split(",")
            if cols[-1] == '':
                cols.pop()
            if not first:
                both = np.asarray(cols, dtype=np.double).tolist()
                num = both.pop()
                if num > 0:
                    num = 1
                elif num < 0:
                    num = -1
                labels.append(num)
                features.append(both)
            else:
                first = False

make_csv('14k.csv')

feat_train, feat_test, lab_train, lab_test = train_test_split(
    features, labels, test_size=0.3
)

scaler = StandardScaler()
scaler.fit(feat_train)
feat_train = scaler.transform(feat_train)
feat_test = scaler.transform(feat_test)

mlp = MLPClassifier(hidden_layer_sizes=(30, 30, 30, 30), max_iter=1000)
mlp.fit(feat_train, lab_train)

y_pred = mlp.predict(feat_test)
accuracy = metrics.accuracy_score(lab_test, y_pred)
print(f"ACCURACY={accuracy:.6f}")

# OPTIMIZATION SUMMARY
# - Removed unused imports (svm, pickle, copy, unittest).
# - Removed model persistence functionality (saveModel, loadModel) and interactive file-based prediction (predict, takeInput).
# - Eliminated all original comments, descriptive print statements, and error handling blocks containing prints.
# - Consolidated the data loading and training/testing workflow into a single execution sequence.
# - Fixed a potential ML coding error where normalization parameters were fit on prediction data instead of training data.
# - Maintained the original MLP architecture, splitting ratio (0.3), and the specific CSV parsing logic.
# - Ensured label thresholding behavior (mapping positive values to 1 and negative to -1) was preserved.