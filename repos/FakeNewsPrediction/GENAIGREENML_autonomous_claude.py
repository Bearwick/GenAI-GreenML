# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.pipeline import Pipeline
import os

def load_csv_robust(path):
    try:
        df = pd.read_csv(path, encoding='utf-8')
        if df.shape[1] <= 1:
            df = pd.read_csv(path, sep=';', decimal=',', encoding='utf-8')
    except Exception:
        df = pd.read_csv(path, sep=';', decimal=',', encoding='utf-8')
    df.columns = [c.strip().replace('  ', ' ') for c in df.columns]
    df = df[[c for c in df.columns if not c.startswith('Unnamed')]]
    return df

fake_path = "Fake.csv"
real_path = "True.csv"

have_two_files = os.path.exists(fake_path) and os.path.exists(real_path)

if have_two_files:
    df_fake = load_csv_robust(fake_path)
    df_real = load_csv_robust(real_path)
    df_fake["label"] = 0
    df_real["label"] = 1
    df = pd.concat([df_fake, df_real], ignore_index=True)
else:
    candidates = [f for f in os.listdir('.') if f.endswith('.csv')]
    if len(candidates) == 0:
        raise FileNotFoundError("No CSV files found in working directory.")
    df = load_csv_robust(candidates[0])
    if 'label' not in df.columns:
        for c in df.columns:
            nuniq = df[c].nunique()
            if nuniq == 2:
                df['label'] = df[c].astype('category').cat.codes
                break
        if 'label' not in df.columns:
            num_cols = df.select_dtypes(include=[np.number]).columns.tolist()
            if num_cols:
                df['label'] = (df[num_cols[0]] > df[num_cols[0]].median()).astype(int)
            else:
                df['label'] = 0

text_col = None
for candidate in ['text', 'Text', 'TEXT']:
    if candidate in df.columns:
        text_col = candidate
        break

if text_col is None:
    str_cols = df.select_dtypes(include=['object']).columns.tolist()
    str_cols = [c for c in str_cols if c != 'label']
    if str_cols:
        avg_lens = {c: df[c].dropna().astype(str).str.len().mean() for c in str_cols}
        text_col = max(avg_lens, key=avg_lens.get)

if text_col is None:
    raise ValueError("No suitable text column found.")

title_col = None
for candidate in ['title', 'Title', 'TITLE']:
    if candidate in df.columns:
        title_col = candidate
        break

if title_col and title_col != text_col:
    df['combined_text'] = df[title_col].fillna('').astype(str) + ' ' + df[text_col].fillna('').astype(str)
else:
    df['combined_text'] = df[text_col].fillna('').astype(str)

df = df[df['combined_text'].str.strip().str.len() > 0].reset_index(drop=True)
assert len(df) > 0, "Dataset empty after removing blank text rows."

y = df['label'].values
X_text = df['combined_text'].values

assert len(np.unique(y)) >= 2, "Target has fewer than 2 classes."

X_train, X_test, y_train, y_test = train_test_split(
    X_text,