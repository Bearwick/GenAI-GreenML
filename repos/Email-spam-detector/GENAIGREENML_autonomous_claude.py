# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import os
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score
from sklearn.pipeline import Pipeline

# Attempt to load the dataset from common file paths
data_path = None
candidates = [
    "email_analysis.csv",
    "emails.csv",
    "spam.csv",
    "data.csv",
    "dataset.csv",
    "train.csv",
]

for c in candidates:
    if os.path.exists(c):
        data_path = c
        break

# Also search current directory for any csv
if data_path is None:
    for f in os.listdir("."):
        if f.endswith(".csv"):
            data_path = f
            break

# If we found a CSV, load it; otherwise try to load from eml directories
df = None

if data_path is not None:
    # Robust CSV loading
    try:
        df = pd.read_csv(data_path, encoding='utf-8', on_bad_lines='skip')
        if df.shape[1] <= 1:
            df = pd.read_csv(data_path, sep=';', decimal=',', encoding='utf-8', on_bad_lines='skip')
    except Exception:
        try:
            df = pd.read_csv(data_path, sep=';', decimal=',', encoding='utf-8', on_bad_lines='skip')
        except Exception:
            df = pd.read_csv(data_path, encoding='latin-1', on_bad_lines='skip')

if df is not None:
    # Normalize column names
    df.columns = [str(c).strip().replace("  ", " ") for c in df.columns]
    df = df[[c for c in df.columns if not c.startswith("Unnamed")]]

    # Determine target and text columns from known headers:
    # Expected: sender, subject, body, urls, filename, label, text
    cols_lower = {c.lower(): c for c in df.columns}

    target_col = None
    for candidate_target in ["label", "Label", "class", "Class", "spam", "target", "y"]:
        if candidate_target in df.columns:
            target_col = candidate_target
            break
        if candidate_target.lower() in cols_lower:
            target_col = cols_lower[candidate_target.lower()]
            break

    text_col = None
    for candidate_text in ["text", "Text", "body", "Body", "message", "Message", "content", "subject"]:
        if candidate_text in df.columns:
            text_col = candidate_text
            break
        if candidate_text.lower() in cols_lower:
            text_col = cols_lower[candidate_text.lower()]
            break

    # If 'text' column exists, use it; otherwise try to build from subject+body
    if text_col is None or text_col == target_col:
        # Try to build text from subject and body
        subj_col = cols_lower.get("subject", None)
        body_col = cols_lower.get("body", None)
        if subj_col and body_col:
            df["_combined_text"] = df[subj_col].fillna("").astype(str) + " " + df[body_col].fillna("").astype(str)
            text_col = "_combined_text"
        elif body_col:
            text_col = body_col
        elif subj_col:
            text_col = subj_col
        else:
            # Pick first object column that is not the target
            obj_cols = [c for c in df.columns if df[c].dtype == object and c != target_col]
            if obj_cols:
                text_col = obj_cols[0]

    # If we have text column but no pre-built 'text', also check if subject+body exist to combine
    if text_col and text_col