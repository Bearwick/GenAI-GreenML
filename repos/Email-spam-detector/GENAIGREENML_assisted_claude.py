# Generated by generate_llm_code.py
# LLM: claude
# Mode: assisted

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score
import numpy as np

RANDOM_SEED = 42

def load_dataset(filepath="emails.csv"):
    try:
        df = pd.read_csv(filepath)
        if df.shape[1] <= 2:
            df = pd.read_csv(filepath, sep=';', decimal=',')
    except Exception:
        df = pd.read_csv(filepath, sep=';', decimal=',')
    return df

def prepare_text(df):
    cols = df.columns.tolist()
    if 'text' in cols and df['text'].notna().all():
        return df
    subject_col = 'subject' if 'subject' in cols else None
    body_col = 'body' if 'body' in cols else None
    if subject_col and body_col:
        df['text'] = df[subject_col].fillna('') + ' ' + df[body_col].fillna('')
    elif subject_col:
        df['text'] = df[subject_col].fillna('')
    elif body_col:
        df['text'] = df[body_col].fillna('')
    elif 'text' in cols:
        df['text'] = df['text'].fillna('')
    else:
        raise ValueError("No text columns found in dataset")
    return df

def train_spam_classifier(df):
    df = prepare_text(df)
    label_col = 'label' if 'label' in df.columns else None
    if label_col is None:
        raise ValueError("No label column found")
    mask = df['text'].notna() & df[label_col].notna()
    df = df[mask]
    vectorizer = TfidfVectorizer(stop_words='english', max_features=5000, dtype=np.float32)
    X = vectorizer.fit_transform(df['text'])
    y = df[label_col]
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=RANDOM_SEED
    )
    model = MultinomialNB()
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    return model, vectorizer, accuracy

if __name__ == "__main__":
    import sys
    filepath = sys.argv[1] if len(sys.argv) > 1 else "emails.csv"
    df = load_dataset(filepath)
    model, vectorizer, accuracy = train_spam_classifier(df)
    print(f"ACCURACY={accuracy:.6f}")

# Optimization Summary
# - Removed file-system .eml loading and BeautifulSoup parsing; reads pre-assembled CSV directly, avoiding heavy I/O and HTML parsing overhead.
# - Removed URL regex extraction since it was unused by the classifier, saving CPU cycles.
# - Removed all print/logging statements except the required accuracy output.
# - Removed CSV artifact saving (email_analysis.csv) and sample prediction that were unnecessary side effects.
# - Removed plots/visualizations (none existed but confirmed).
# - Used np.float32 dtype in TfidfVectorizer to reduce memory footprint of the sparse matrix.
# - Combined text preparation into a single efficient step with fillna to avoid redundant operations.
# - Added robust CSV fallback parsing (default then sep=';' with decimal=',').
# - Fixed random seed for reproducibility.
# - Removed classification_report computation since only accuracy is needed, saving string formatting overhead.
# - Removed interactive inputs; filepath is taken from command-line arg or defaults.
# - Kept MultinomialNB as the lightweight model matching original behavior.