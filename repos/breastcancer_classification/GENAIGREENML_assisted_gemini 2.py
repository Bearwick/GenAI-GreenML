# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import numpy as np
    import pandas as pd

    def sigmoid(z):
        return 1 / (1 + np.exp(-z))

    def train(x, y, iters, alpha):
        m = x.shape[1]
        w = np.zeros((x.shape[0], 1))
        b = 0.0
        lr_m = alpha / m
        
        for _ in range(iters):
            z = np.dot(w.T, x) + b
            a = 1 / (1 + np.exp(-z))
            dz = a - y
            w -= lr_m * np.dot(x, dz.T)
            b -= lr_m * np.sum(dz)
        return w, b

    def main():
        df_x_train = pd.read_csv("cancer_data.csv")
        df_y_train = pd.read_csv("cancer_data_y.csv")
        df_x_test = pd.read_csv("test_cancer_data.csv")
        df_y_test = pd.read_csv("test_cancer_data_y.csv")

        x_train = df_x_train.values.T
        y_train = df_y_train.values.T
        x_test = df_x_test.values.T
        y_test = df_y_test.values.T

        iters = 190500
        alpha = 0.000000065

        w, b = train(x_train, y_train, iters, alpha)

        z_test = np.dot(w.T, x_test) + b
        a_test = 1 / (1 + np.exp(-z_test))
        y_pred = (a_test > 0.5).astype(float)

        accuracy = np.mean(y_pred == y_test)
        print(f"ACCURACY={accuracy:.6f}")

    if __name__ == "__main__":
        main()

    # OPTIMIZATIONS APPLIED:
    # 1. Vectorization: Replaced manual loops for prediction and performance metrics with NumPy vectorized operations to improve runtime.
    # 2. Computational Efficiency: Eliminated the expensive log-based cost calculation inside the high-iteration training loop.
    # 3. Memory Footprint: Removed storage of cost history, redundant gradient dictionaries, and intermediate list structures.
    # 4. Arithmetic Optimization: Pre-calculated the constant learning rate coefficient (alpha/m) to reduce total floating-point operations.
    # 5. Redundancy Removal: Streamlined the data pipeline by eliminating multiple redundant transpositions and array-to-list conversions.
    # 6. Overhead reduction: Removed all plotting, original print statements, and unnecessary interactive inputs to minimize CPU cycles and energy.