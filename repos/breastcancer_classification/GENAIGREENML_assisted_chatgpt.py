# Generated by generate_llm_code.py
# LLM: chatgpt
# Mode: assisted

import numpy as np
import pandas as pd


def _load_csv_as_float32(path: str) -> np.ndarray:
    return pd.read_csv(path).to_numpy(dtype=np.float32, copy=False)


def sigmoid(z: np.ndarray) -> np.ndarray:
    z = np.clip(z, -40.0, 40.0)
    return 1.0 / (1.0 + np.exp(-z))


def initialize(dim: int) -> tuple[np.ndarray, float]:
    return np.zeros((dim, 1), dtype=np.float32), 0.0


def propagate(w: np.ndarray, b: float, X: np.ndarray, Y: np.ndarray) -> tuple[np.ndarray, float, float]:
    m = X.shape[1]
    z = (w.T @ X) + b
    A = sigmoid(z)

    eps = 1e-7
    A_clip = np.clip(A, eps, 1.0 - eps)
    cost = (-1.0 / m) * np.sum(Y * np.log(A_clip) + (1.0 - Y) * np.log(1.0 - A_clip))

    dZ = A - Y
    dw = (1.0 / m) * (X @ dZ.T)
    db = float((1.0 / m) * np.sum(dZ))
    return dw, db, float(cost)


def optimize(
    w: np.ndarray,
    b: float,
    X: np.ndarray,
    Y: np.ndarray,
    num_iters: int,
    alpha: float,
) -> tuple[np.ndarray, float]:
    for _ in range(num_iters):
        dw, db, _ = propagate(w, b, X, Y)
        w -= alpha * dw
        b -= alpha * db
    return w, b


def predict(w: np.ndarray, b: float, X: np.ndarray) -> np.ndarray:
    A = sigmoid((w.T @ X) + b)
    return (A > 0.5).astype(np.float32)


def accuracy_from_preds(y_pred: np.ndarray, y_true: np.ndarray) -> float:
    return 1.0 - float(np.mean(np.abs(y_pred - y_true)))


def model(X_train: np.ndarray, Y_train: np.ndarray, num_iters: int = 2000, alpha: float = 0.5) -> float:
    w, b = initialize(X_train.shape[0])
    w, b = optimize(w, b, X_train, Y_train, num_iters=num_iters, alpha=alpha)

    X_test = _load_csv_as_float32("test_cancer_data.csv").T
    Y_test = _load_csv_as_float32("test_cancer_data_y.csv").T

    y_prediction_test = predict(w, b, X_test)
    return accuracy_from_preds(y_prediction_test, Y_test)


def main() -> None:
    X_train = _load_csv_as_float32("cancer_data.csv").T
    Y_train = _load_csv_as_float32("cancer_data_y.csv").T

    accuracy = model(X_train, Y_train, num_iters=190500, alpha=0.000000065)
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# OPTIMIZATION SUMMARY
# - Removed unused imports (matplotlib) and all plotting to cut runtime and energy.
# - Avoided repeated pandas->numpy conversions and redundant arrays by loading once via a helper and using to_numpy(copy=False).
# - Switched to float32 to reduce memory footprint and improve cache efficiency while keeping outputs consistent for this task.
# - Vectorized prediction thresholding (removed Python loop) to reduce overhead and speed up inference.
# - Removed conversion to Python lists and per-sample confusion-matrix loops (not required for final accuracy output).
# - Eliminated storing/collecting costs and print_cost logic to avoid extra computation and memory allocations.
# - Added numerically-stable sigmoid/cost via clipping to avoid overflow/NaNs and ensure reproducible, stable training.