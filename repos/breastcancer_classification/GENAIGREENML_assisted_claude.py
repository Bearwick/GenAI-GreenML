# Generated by generate_llm_code.py
# LLM: claude
# Mode: assisted

import numpy as np
import pandas as pd


def load_csv(path):
    df = pd.read_csv(path)
    if df.shape[1] <= 1:
        df = pd.read_csv(path, sep=';', decimal=',')
    return df.values


def sigmoid(z):
    return 1.0 / (1.0 + np.exp(-z))


def initialize(dim):
    return np.zeros((dim, 1)), 0.0


def propagate(w, b, X, Y, m_inv):
    A = sigmoid(w.T @ X + b)
    cost = -m_inv * np.sum(Y * np.log(A) + (1.0 - Y) * np.log(1.0 - A))
    dw = m_inv * (X @ (A - Y).T)
    db = m_inv * np.sum(A - Y)
    return dw, db, float(np.squeeze(cost))


def optimize(w, b, X, Y, num_iters, alpha):
    m_inv = 1.0 / X.shape[1]
    for _ in range(num_iters):
        dw, db, cost = propagate(w, b, X, Y, m_inv)
        w = w - alpha * dw
        b = b - alpha * db
    return w, b


def predict(w, b, X):
    A = sigmoid(w.T @ X + b)
    return (A > 0.5).astype(np.float64)


def main():
    train_x = load_csv("cancer_data.csv")
    train_y = load_csv("cancer_data_y.csv")
    X_train = train_x.T
    Y_train = train_y.T

    w, b = initialize(X_train.shape[0])
    w, b = optimize(w, b, X_train, Y_train, num_iters=190500, alpha=0.000000065)

    X_test = load_csv("test_cancer_data.csv").T
    Y_test = load_csv("test_cancer_data_y.csv").T

    y_prediction_test = predict(w, b, X_test)
    accuracy = 1.0 - np.mean(np.abs(y_prediction_test - Y_test))
    print(f"ACCURACY={accuracy:.6f}")


main()

# Optimization Summary
# Removed matplotlib import and all plotting to save memory and compute.
# Removed all print statements and logging except final accuracy.
# Removed redundant confusion matrix loops; accuracy computed directly via vectorized numpy.
# Eliminated dictionary intermediaries (grads, params, costs list) to reduce memory allocations.
# Precomputed m_inv (1/m) once outside the loop instead of recomputing each iteration.
# Used numpy @ operator instead of np.dot for clarity and equivalent performance.
# Vectorized predict using boolean comparison instead of Python for-loop.
# Removed unused train accuracy computation since output only requires test accuracy.
# Added robust CSV fallback (sep=';', decimal=',') per requirements.
# No interactive inputs or file artifacts saved.