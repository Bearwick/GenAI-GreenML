# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score

# --- Robust CSV Loading ---
DATASET_PATH = "cancer_data.csv"

try:
    df = pd.read_csv(DATASET_PATH)
except Exception:
    df = pd.read_csv(DATASET_PATH, sep=';', decimal=',')

# Check if parsing produced very few columns; retry with alternate separator
if df.shape[1] < 5:
    try:
        df = pd.read_csv(DATASET_PATH, sep=';', decimal=',')
    except Exception:
        pass

# --- Column Name Normalization ---
df.columns = df.columns.astype(str).str.strip().str.replace(r'\s+', ' ', regex=True)
df = df.loc[:, ~df.columns.str.startswith('Unnamed')]

# --- Detect if header row is actually data (all numeric header names) ---
# The dataset headers provided are all numeric values, suggesting no real header row.
# Check if all column names can be cast to float:
all_numeric_headers = True
for c in df.columns:
    try:
        float(c)
    except ValueError:
        all_numeric_headers = False
        break

if all_numeric_headers:
    # Reload without header; the first row was data, not column names
    try:
        df = pd.read_csv(DATASET_PATH, header=None)
    except Exception:
        df = pd.read_csv(DATASET_PATH, header=None, sep=';', decimal=',')
    if df.shape[1] < 5:
        try:
            df = pd.read_csv(DATASET_PATH, header=None, sep=';', decimal=',')
        except Exception:
            pass

# --- Assign meaningful column names based on Wisconsin Breast Cancer dataset ---
# The UCI Wisconsin Diagnostic Breast Cancer dataset has: id, diagnosis, then 30 features
# OR just diagnosis + 30 features, OR 30 features + diagnosis, etc.
# From context: 30 features used, classes are benign/malignant.
# The DATASET_HEADERS show 30 numeric columns. Let's check actual shape.

n_cols = df.shape[1]

# Try to identify the target column
# Look for a column with exactly 2 unique values or a column that looks like diagnosis
target_col = None
feature_cols = []

# First, check if any column is string/object type (like 'M'/'B' diagnosis)
for c in df.columns:
    if df[c].dtype == object:
        unique_vals = df[c].dropna().unique()
        if len(unique_vals) == 2:
            target_col = c
            break

if target_col is None:
    # All columns appear numeric; coerce everything
    for c in df.columns:
        df[c] = pd.to_numeric(df[c], errors='coerce')

    # Look for a column with exactly 2 unique non-NaN values (likely the label)
    for c in df.columns:
        nunique = df[c].dropna().nunique()
        if nunique == 2:
            target_col = c
            break

    # If still not found, check for columns with very few unique values
    if target_col is None:
        min_unique = float('inf')
        for c in df.columns:
            nunique = df[c].dropna().nunique()
            if 2 <= nunique <= 5 and nunique < min_unique:
                min_unique = nunique
                target_col = c

# If still no target found, use the last column as target (common convention)
if target_col is None:
    target_col = df.columns[-1]

# Build feature columns
feature_cols = [c for c in df.columns if c != target_col]

# --- Handle target encoding ---
y = df[target_col].copy()

if y