# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score

DATASET_PATH = "cancer_data.csv"

# Robust CSV loading
try:
    df = pd.read_csv(DATASET_PATH)
except Exception:
    df = pd.read_csv(DATASET_PATH, sep=';', decimal=',')

# Check if the first row looks like data rather than headers
# The dataset headers provided look like numeric values, suggesting no header row
# If all column names are numeric-looking, reload without header
try:
    all_numeric_cols = all(
        isinstance(c, (int, float)) or c.replace('.', '', 1).replace('-', '', 1).replace('+', '', 1).replace('e', '', 1).isdigit()
        for c in df.columns
    )
except Exception:
    all_numeric_cols = False

if all_numeric_cols or df.shape[1] == 30:
    # Likely no header row; the "headers" are actually the first data row
    df = pd.read_csv(DATASET_PATH, header=None)

# If still looks wrong, try semicolon separator
if df.shape[1] <= 2:
    df = pd.read_csv(DATASET_PATH, header=None, sep=';', decimal=',')

# Strip/normalize column names
df.columns = [str(c).strip() for c in df.columns]
df = df[[c for c in df.columns if not c.startswith('Unnamed')]]

# According to UCI Breast Cancer Wisconsin (Diagnostic) dataset and the readme:
# 30 features + possibly an ID column and/or a diagnosis column
# The provided headers are 30 numeric values, so dataset might have 30, 31, or 32 columns
# Typical layout: id, diagnosis, 30 features  OR  30 features + target  OR just 30 features

# Try to load the canonical sklearn breast cancer dataset column names for reference
feature_names_30 = [
    'mean_radius', 'mean_texture', 'mean_perimeter', 'mean_area', 'mean_smoothness',
    'mean_compactness', 'mean_concavity', 'mean_concave_points', 'mean_symmetry', 'mean_fractal_dim',
    'se_radius', 'se_texture', 'se_perimeter', 'se_area', 'se_smoothness',
    'se_compactness', 'se_concavity', 'se_concave_points', 'se_symmetry', 'se_fractal_dim',
    'worst_radius', 'worst_texture', 'worst_perimeter', 'worst_area', 'worst_smoothness',
    'worst_compactness', 'worst_concavity', 'worst_concave_points', 'worst_symmetry', 'worst_fractal_dim'
]

n_cols = df.shape[1]

# Detect target column
# Look for a column that contains string values like 'M'/'B' or integer values like 0/1 or 1/2
target_col = None
target_series = None

for col in df.columns:
    col_data = df[col]
    # Check for string diagnosis column
    if col_data.dtype == object:
        unique_vals = set(col_data.dropna().astype(str).str.strip().str.upper())
        if unique_vals <= {'M', 'B'} and len(unique_vals) == 2:
            target_col = col
            target_series = col_data.astype(str).str.strip().str.upper().map({'M': 1, 'B': 0})
            break

if target_col is None:
    # Check for columns with very few unique values that could be target
    # The readme mentions 1=benign, 2=malignant or 0/1
    for col in df