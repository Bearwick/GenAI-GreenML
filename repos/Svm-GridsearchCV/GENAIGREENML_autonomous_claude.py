# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score

# Robust CSV loading
dt = "bodyPerformance.csv"
try:
    df = pd.read_csv(dt)
    if df.shape[1] < 3:
        df = pd.read_csv(dt, sep=';', decimal=',')
except Exception:
    df = pd.read_csv(dt, sep=';', decimal=',')

# Normalize column names
df.columns = df.columns.str.strip().str.replace(r'\s+', ' ', regex=True)
df = df[[c for c in df.columns if not c.startswith('Unnamed')]]

# Identify target column
expected_target = 'Blass'
target_col = None
for c in df.columns:
    if c.lower() == expected_target.lower():
        target_col = c
        break

if target_col is None:
    # Fallback: use the last column as target
    target_col = df.columns[-1]

# Separate features and target
feature_cols = [c for c in df.columns if c != target_col]

# Encode target if it is categorical/object
y_raw = df[target_col].copy()
le = LabelEncoder()
if y_raw.dtype == object or y_raw.dtype.name == 'category':
    y = le.fit_transform(y_raw.astype(str))
else:
    # Check if it looks like classification (few unique values) or regression
    nunique = y_raw.nunique()
    if nunique <= 30:
        y = le.fit_transform(y_raw.astype(str))
    else:
        y = y_raw.values

# Encode any categorical feature columns and coerce numerics
X = df[list(feature_cols)].copy()

# One-hot encode object columns, coerce numeric columns
cat_cols = X.select_dtypes(include=['object', 'category']).columns.tolist()
num_cols = [c for c in X.columns if c not in cat_cols]

for c in num_cols:
    X[c] = pd.to_numeric(X[c], errors='coerce')

if cat_cols:
    X = pd.get_dummies(X, columns=cat_cols, drop_first=True)

# Handle NaN/inf
X.replace([np.inf, -np.inf], np.nan, inplace=True)
valid_mask = X.notna().all(axis=1) & pd.Series(~pd.isna(y), index=X.index)
X = X.loc[valid_mask]
y = y[valid_mask.values] if isinstance(y, np.ndarray) else y.loc[valid_mask]

# Fill remaining NaN with median for safety
for c in X.columns:
    if X[c].isna().any():
        X[c].fillna(X[c].median(), inplace=True)

assert X.shape[0] > 0, "Dataset is empty after preprocessing"

# Determine task type
unique_classes = np.unique(y)
is_classification = len(unique_classes) >= 2 and len(unique_classes) <= 50

if len(unique_classes) < 2:
    # Trivial baseline: predict constant
    accuracy = 1.0
    print(f"ACCURACY={accuracy:.6f}")
    import sys
    sys.exit(0)

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y if is_classification else None
)

assert X_train.shape[0] > 0 and X_test.shape[0] > 0, "Train/test split produced empty sets"

if is_classification:
    # Lightweight logistic