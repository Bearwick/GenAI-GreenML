# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import os
import pickle
import random
import warnings

import numpy as np
import pandas as pd
import sklearn.neighbors

SEED = 42
random.seed(SEED)
np.random.seed(SEED)
warnings.filterwarnings("ignore")

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_PATH = os.path.join(BASE_DIR, "dict.pickle")
INPUT_PATH = os.path.join(BASE_DIR, "input.csv")


def read_csv_robust(path):
    try:
        df = pd.read_csv(path)
    except Exception:
        return pd.read_csv(path, sep=";", decimal=",")
    if df.shape[1] == 1 and not df.empty:
        sample = df.iloc[0, 0]
        if isinstance(sample, str) and ";" in sample:
            try:
                alt = pd.read_csv(path, sep=";", decimal=",")
                if alt.shape[1] > 1:
                    df = alt
            except Exception:
                pass
    return df


def resolve_columns(df):
    headers = None
    if "DATASET_HEADERS" in globals():
        hdr = globals()["DATASET_HEADERS"]
        if isinstance(hdr, dict):
            headers = list(hdr.keys())
        else:
            try:
                headers = list(hdr)
            except Exception:
                headers = None
    if headers:
        cols = [c for c in headers if c in df.columns]
        if cols:
            return cols
    return list(df.columns)


def normalize_dataframe(df):
    cols = resolve_columns(df)
    df = df.loc[:, cols]
    df = df.apply(pd.to_numeric, errors="coerce")
    df = df.dropna(axis=1, how="all")
    df = df.dropna(axis=0, how="any")
    return df


def load_input_data(path, model):
    if not os.path.exists(path):
        return None, None
    df = read_csv_robust(path)
    if df.empty:
        return None, None
    df = normalize_dataframe(df)
    if df.empty:
        return None, None
    n_features = None
    if model is not None:
        if hasattr(model, "_fit_X"):
            try:
                n_features = model._fit_X.shape[1]
            except Exception:
                n_features = None
        if n_features is None and hasattr(model, "n_features_in_"):
            try:
                n_features = int(model.n_features_in_)
            except Exception:
                n_features = None
    y = None
    if n_features is not None:
        if df.shape[1] == n_features + 1:
            X_df = df.iloc[:, :n_features]
            y = df.iloc[:, n_features].to_numpy()
        elif df.shape[1] >= n_features:
            X_df = df.iloc[:, :n_features]
        else:
            X_df = df
    else:
        X_df = df
    X = X_df.to_numpy(copy=False)
    return X, y


def load_model(path):
    with open(path, "rb") as f:
        return pickle.load(f)


def to_1d_array(arr):
    if arr is None:
        return None
    return np.ravel(np.asarray(arr))


def compute_accuracy(model, X=None, y=None, preds=None):
    if model is None:
        return 0.0
    if X is not None and y is not None:
        y_flat = to_1d_array(y)
        if len(y_flat) == len(X) and len(y_flat) > 0:
            if preds is None:
                try:
                    return float(model.score(X, y_flat))
                except Exception:
                    try:
                        preds = model.predict(X)
                    except Exception:
                        return 0.0
            preds_flat = to_1d_array(preds)
            return float(np.mean(preds_flat == y_flat))
    X_train = getattr(model, "_fit_X", None)
    y_train = getattr(model, "_y", None)
    if X_train is None or y_train is None:
        X_train = getattr(model, "X_", None)
        y_train = getattr(model, "y_", None)
    if X_train is None or y_train is None:
        return 0.0
    y_train_flat = to_1d_array(y_train)
    if len(y_train_flat) == 0:
        return 0.0
    try:
        return float(model.score(X_train, y_train_flat))
    except Exception:
        try:
            preds_train = model.predict(X_train)
            preds_train_flat = to_1d_array(preds_train)
            return float(np.mean(preds_train_flat == y_train_flat))
        except Exception:
            return 0.0


def main():
    model = load_model(MODEL_PATH)
    X_input, y_input = load_input_data(INPUT_PATH, model)
    preds = None
    if X_input is not None and y_input is not None and len(X_input) > 0 and len(y_input) == len(X_input):
        try:
            preds = model.predict(X_input)
        except Exception:
            preds = None
    accuracy = compute_accuracy(model, X_input, y_input, preds)
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# - Removed unused training, saving, and unit test paths to reduce runtime overhead.
# - Replaced manual CSV parsing with vectorized pandas loading and numeric coercion.
# - Added robust CSV fallback parsing to avoid repeated read failures.
# - Avoided redundant predictions by only computing them when used for accuracy.
# - Reused model-stored training data for accuracy without extra file I/O.
# - Fixed random seeds and suppressed warnings for deterministic, clean output.