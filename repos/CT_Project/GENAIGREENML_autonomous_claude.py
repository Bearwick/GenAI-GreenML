# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
import os
import sys

# Suppress warnings for clean output
import warnings
warnings.filterwarnings("ignore")

# --- Robust CSV Loading ---
data_path = None
candidates = ["mail_data.csv", "spam_email.csv", "spam.csv", "data.csv", "dataset.csv"]
for c in candidates:
    if os.path.isfile(c):
        data_path = c
        break

if data_path is None:
    for f in os.listdir("."):
        if f.endswith(".csv"):
            data_path = f
            break

if data_path is None:
    print("ACCURACY=0.000000")
    sys.exit(0)

# Try default parsing first
try:
    df = pd.read_csv(data_path, encoding="utf-8")
except Exception:
    try:
        df = pd.read_csv(data_path, encoding="latin-1")
    except Exception:
        df = pd.read_csv(data_path, encoding="utf-8", sep=";", decimal=",")

# If only 1 column, retry with sep=';'
if df.shape[1] < 2:
    try:
        df2 = pd.read_csv(data_path, sep=";", decimal=",", encoding="utf-8")
        if df2.shape[1] >= 2:
            df = df2
    except Exception:
        pass

# --- Column Name Normalization ---
df.columns = [str(c).strip().replace("  ", " ") for c in df.columns]
df = df[[c for c in df.columns if not c.startswith("Unnamed")]]

# --- Identify target and text columns ---
target_col = None
text_col = None

# Check for expected headers
col_lower_map = {c.lower(): c for c in df.columns}

if "category" in col_lower_map:
    target_col = col_lower_map["category"]
elif "label" in col_lower_map:
    target_col = col_lower_map["label"]
elif "class" in col_lower_map:
    target_col = col_lower_map["class"]
elif "v1" in col_lower_map:
    target_col = col_lower_map["v1"]

if "message" in col_lower_map:
    text_col = col_lower_map["message"]
elif "text" in col_lower_map:
    text_col = col_lower_map["text"]
elif "sms" in col_lower_map:
    text_col = col_lower_map["sms"]
elif "v2" in col_lower_map:
    text_col = col_lower_map["v2"]

# Fallback: if we have exactly 2 columns, assume first is target, second is text
if target_col is None or text_col is None:
    if df.shape[1] >= 2:
        if target_col is None:
            target_col = df.columns[0]
        if text_col is None:
            text_col = df.columns[1]
    else:
        print("ACCURACY=0.000000")
        sys.exit(0)

# --- Preprocessing ---
df = df[[target_col, text_col]].copy()
df[text_col] = df[text_col].fillna("").astype(str)
df[target_col] = df[target_col].astype(str).str.strip().str.lower()

# Encode target: spam -> 0, ham -> 1; handle other encodings
unique_labels = df[target_col].unique()

label_map = {}
if "spam" in unique_labels and "ham" in unique_labels:
    label_map = {"spam": 0, "ham": 1}
elif set(unique_labels).issubset