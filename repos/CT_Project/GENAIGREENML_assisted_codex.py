# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import numpy as np
import pandas as pd
import warnings
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.exceptions import ConvergenceWarning

warnings.filterwarnings("ignore", category=ConvergenceWarning)
np.random.seed(42)

DATASET_PATH = "mail_data.csv"
DATASET_HEADERS = ["Category", "Message"]


def read_csv_robust(path, expected_headers):
    try:
        df = pd.read_csv(path)
    except Exception:
        return pd.read_csv(path, sep=";", decimal=",")
    if df.shape[1] < len(expected_headers) or not set(expected_headers).issubset(df.columns):
        try:
            df_alt = pd.read_csv(path, sep=";", decimal=",")
            if df_alt.shape[1] >= len(expected_headers):
                df = df_alt
        except Exception:
            pass
    return df


def align_columns(df, expected_headers):
    lower_map = {c.lower(): c for c in df.columns}
    matched = []
    for header in expected_headers:
        col = header if header in df.columns else lower_map.get(header.lower())
        if col is not None:
            matched.append(col)
    if len(matched) == len(expected_headers):
        df = df.loc[:, matched].copy()
        df.columns = expected_headers
    else:
        df = df.iloc[:, :len(expected_headers)].copy()
        df.columns = expected_headers
    return df


def load_data(path, expected_headers):
    df = read_csv_robust(path, expected_headers)
    df = align_columns(df, expected_headers)
    df.fillna("", inplace=True)
    df["Category"] = (
        df["Category"].astype(str).str.lower().map({"spam": 0, "ham": 1}).astype("int64")
    )
    return df["Message"], df["Category"]


def train_evaluate(X, y):
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=3
    )
    vectorizer = TfidfVectorizer(min_df=1, stop_words="english", lowercase=True)
    X_train_features = vectorizer.fit_transform(X_train)
    X_test_features = vectorizer.transform(X_test)
    model = LogisticRegression(random_state=42)
    model.fit(X_train_features, y_train)
    predictions = model.predict(X_test_features)
    return accuracy_score(y_test, predictions)


def main():
    X, y = load_data(DATASET_PATH, DATASET_HEADERS)
    accuracy = train_evaluate(X, y)
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# Consolidated preprocessing and label encoding to avoid redundant dataframe operations.
# Removed unnecessary dataset inspections, training accuracy, and demo predictions to cut extra compute.
# Added robust CSV parsing and column alignment with minimal copying for reliable input handling.
# Applied deterministic seeds and suppressed convergence warnings for stable, clean output.
# Streamlined feature extraction and evaluation to reduce data movement and runtime.