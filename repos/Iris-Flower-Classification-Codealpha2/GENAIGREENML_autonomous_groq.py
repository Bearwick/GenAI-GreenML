# Generated by generate_llm_code.py
# LLM: groq
# Mode: autonomous

"""
This script trains a lightweight classifier for the Iris dataset while prioritising energy efficiency:

- Uses only standard libraries and scikit‑learn, avoiding heavyweight deep‑learning frameworks.
- Employs a simple `StandardScaler` followed by a `LogisticRegression` (or `SVC` with a linear kernel), which are computationally inexpensive and suitable for small tabular data.
- Skips any visualisation or cross‑validation to reduce runtime and memory usage.
- Prints a single accuracy value with six decimal places, ensuring minimal console I/O.

All preprocessing steps (column removal, label encoding, train/test split) are deterministic via fixed random states.
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

def main():
    # Load dataset
    df = pd.read_csv("Iris.csv")

    # Drop identifier column if present
    if "Id" in df.columns:
        df = df.drop(columns=["Id"])

    # Encode target labels
    le = LabelEncoder()
    df["Species"] = le.fit_transform(df["Species"])

    # Separate features and target
    X = df.drop(columns=["Species"])
    y = df["Species"]

    # Train‑test split with reproducibility
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )

    # Lightweight preprocessing + model pipeline
    pipeline = Pipeline([
        ("scaler", StandardScaler()),
        ("clf", LogisticRegression(max_iter=200, random_state=42))
    ])

    # Train and evaluate
    pipeline.fit(X_train, y_train)
    y_pred = pipeline.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)

    # Output only the required accuracy
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()