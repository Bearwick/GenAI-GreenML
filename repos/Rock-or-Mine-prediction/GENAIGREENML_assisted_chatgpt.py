# Generated by generate_llm_code.py
# LLM: chatgpt
# Mode: assisted

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score


SEED = 1
DATASET_PATH = "Sonar Data.csv"


def _read_csv_robust(path: str) -> pd.DataFrame:
    df = pd.read_csv(path, header=None)
    if df.shape[1] <= 1:
        df = pd.read_csv(path, header=None, sep=";", decimal=",")
    return df


def _get_target_column_index(df: pd.DataFrame) -> int:
    n_cols = df.shape[1]
    if n_cols <= 1:
        raise ValueError("Parsed dataset has too few columns; check CSV formatting.")
    return n_cols - 1


def _prepare_features_target(df: pd.DataFrame, target_col: int):
    X = df.drop(columns=[target_col])
    y = df[target_col]
    return X, y


def main() -> None:
    np.random.seed(SEED)

    df = _read_csv_robust(DATASET_PATH)
    target_col = _get_target_column_index(df)
    X, y = _prepare_features_target(df, target_col)

    X_train, X_test, y_train, y_test = train_test_split(
        X,
        y,
        test_size=0.7,
        stratify=y,
        random_state=SEED,
    )

    model = LogisticRegression(max_iter=200, solver="liblinear", random_state=SEED)
    model.fit(X_train, y_train)

    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# - Removed unused exploratory computations (describe/value_counts/groupby) to avoid redundant full-data scans.
# - Eliminated all intermediate prints/logging; only final accuracy is printed as required.
# - Added robust CSV parsing with a fallback delimiter/decimal to prevent costly mis-parses and rework.
# - Derived target column index from df.shape instead of assuming fixed schema, reducing fragility and retries.
# - Ensured reproducibility with a fixed seed for NumPy and train/test split; set model random_state.
# - Computed accuracy only on the test split (single predict call) to reduce extra inference work.
# - Chose a lightweight, deterministic-ish solver (liblinear) and bounded iterations to reduce runtime/energy while preserving task behavior.