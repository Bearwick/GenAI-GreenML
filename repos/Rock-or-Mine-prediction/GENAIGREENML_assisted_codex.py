# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

SEED = 1
np.random.seed(SEED)

DATASET_PATH = "Sonar Data.csv"
DATASET_HEADERS = (
    "0.0200,0.0371,0.0428,0.0207,0.0954,0.0986,0.1539,0.1601,0.3109,0.2111,"
    "0.1609,0.1582,0.2238,0.0645,0.0660,0.2273,0.3100,0.2999,0.5078,0.4797,"
    "0.5783,0.5071,0.4328,0.5550,0.6711,0.6415,0.7104,0.8080,0.6791,0.3857,"
    "0.1307,0.2604,0.5121,0.7547,0.8537,0.8507,0.6692,0.6097,0.4943,0.2744,"
    "0.0510,0.2834,0.2825,0.4256,0.2641,0.1386,0.1051,0.1343,0.0383,0.0324,"
    "0.0232,0.0027,0.0065,0.0159,0.0072,0.0167,0.0180,0.0084,0.0090,0.0032,R"
)

def parse_headers(header_str):
    return [h.strip() for h in header_str.split(",") if h.strip()]

def needs_header_none(df, headers):
    expected = len(headers)
    if df.shape[1] != expected:
        return True
    if isinstance(df.columns, pd.RangeIndex):
        return False
    cols = [str(c) for c in df.columns]
    if cols == headers:
        return True
    numeric_like = 0
    for c in cols[:-1]:
        try:
            float(c)
            numeric_like += 1
        except ValueError:
            break
    if numeric_like == len(cols) - 1:
        return True
    return False

def load_dataframe(path, headers):
    df = pd.read_csv(path)
    if needs_header_none(df, headers):
        df = pd.read_csv(path, header=None)
    if df.shape[1] == 1 or df.shape[1] != len(headers):
        df = pd.read_csv(path, sep=";", decimal=",", header=None)
    return df

headers = parse_headers(DATASET_HEADERS)
df = load_dataframe(DATASET_PATH, headers)

X = df.iloc[:, :-1].to_numpy()
y = df.iloc[:, -1].to_numpy()

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.7, stratify=y, random_state=SEED
)

model = LogisticRegression()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"ACCURACY={accuracy:.6f}")

# Optimization Summary
# Removed unused exploratory computations and logging to reduce overhead.
# Used direct column slicing to avoid extra DataFrame copies.
# Implemented robust CSV parsing with minimal re-reads and schema checks.
# Skipped training accuracy computation to eliminate redundant predictions.
# Set a fixed random seed for reproducibility without extra computation.