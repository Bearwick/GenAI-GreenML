# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score

# Robust CSV loading
def load_csv_robust(path):
    try:
        df = pd.read_csv(path, header=0)
        if df.shape[1] < 2:
            df = pd.read_csv(path, header=0, sep=';', decimal=',')
    except Exception:
        df = pd.read_csv(path, header=0, sep=';', decimal=',')
    df.columns = [c.strip() for c in df.columns]
    df = df[[c for c in df.columns if not c.startswith('Unnamed')]]
    return df

# Load train and test
docs = load_csv_robust('movie_review_train.csv')
docs_test = load_csv_robust('movie_review_test.csv')

# Normalize column names: try to find class and text columns
def find_col(df, candidates):
    cols_lower = {c.lower(): c for c in df.columns}
    for cand in candidates:
        if cand.lower() in cols_lower:
            return cols_lower[cand.lower()]
    return None

class_col = find_col(docs, ['class', 'Class', 'label', 'target', 'category'])
text_col = find_col(docs, ['text', 'Text', 'review', 'document', 'content'])

if class_col is None or text_col is None:
    # Fallback: assume first col is class, second is text
    class_col = docs.columns[0]
    text_col = docs.columns[1]

# Also resolve for test
class_col_test = find_col(docs_test, [class_col, 'class', 'Class', 'label', 'target', 'category'])
text_col_test = find_col(docs_test, [text_col, 'text', 'Text', 'review', 'document', 'content'])
if class_col_test is None:
    class_col_test = docs_test.columns[0]
if text_col_test is None:
    text_col_test = docs_test.columns[1]

# Drop rows with missing text or class
docs = docs.dropna(subset=[class_col, text_col]).reset_index(drop=True)
docs_test = docs_test.dropna(subset=[class_col_test, text_col_test]).reset_index(drop=True)

# Map labels to numeric
unique_labels = sorted(docs[class_col].unique())
label_map = {lbl: idx for idx, lbl in enumerate(unique_labels)}

docs['label'] = docs[class_col].map(label_map)
docs_test['label'] = docs_test[class_col_test].map(label_map)

# Drop any rows where mapping failed
docs = docs.dropna(subset=['label']).reset_index(drop=True)
docs_test = docs_test.dropna(subset=['label']).reset_index(drop=True)

X_train = docs[text_col].astype(str)
y_train = docs['label'].astype(int)
X_test = docs_test[text_col_test].astype(str)
y_test = docs_test['label'].astype(int)

assert len(X_train) > 0, "Training set is empty after preprocessing"
assert len(X_test) > 0, "Test set is empty after preprocessing"
assert y_train.nunique() >= 2, "Need at least 2 classes for classification"

# Lightweight text vectorization with CountVectorizer
vect = CountVectorizer(stop_words='english', min_df=0.03, max_df=0.8)
X_train_transformed = vect.fit_transform(X_train)
X_test_transformed = vect.transform(X_test)

# Multinomial Naive Bayes - energy efficient, CPU friendly