# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import pandas as pd
import numpy as np

def algorithm():
    k = 1
    
    train_df = pd.read_csv('Data/Diabetes-Training.csv')
    test_df = pd.read_csv('Data/Diabetes-Clasification.csv')
    
    x_train_raw = train_df.iloc[:, :-1]
    x_test_raw = test_df.iloc[:, :-1]
    
    y_train = train_df.iloc[:, -1].values
    y_test = test_df.iloc[:, -1].values
    
    x_train = (x_train_raw - x_train_raw.mean()) / x_train_raw.std()
    x_test = (x_test_raw - x_test_raw.mean()) / x_test_raw.std()
    
    x_train = x_train.values
    x_test = x_test.values
    
    dists_sq = np.sum(x_test**2, axis=1)[:, np.newaxis] + np.sum(x_train**2, axis=1) - 2 * np.dot(x_test, x_train.T)
    
    nn_indices = np.argmin(dists_sq, axis=1)
    predictions = y_train[nn_indices]
    
    accuracy = np.mean(predictions == y_test)
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    algorithm()

# OPTIMIZATIONS APPLIED:
# 1. Vectorized Distance Calculation: Replaced the manual O(N*M) Python loop for Euclidean distance with a 
#    highly optimized matrix-based (A^2 + B^2 - 2AB) approach. This leverages BLAS libraries and 
#    drastically reduces CPU time and energy consumption.
# 2. Algorithmic Complexity Reduction: Used np.argmin to find the nearest neighbor in O(N) time 
#    instead of sorting the entire distance list in O(N log N) time for every test instance.
# 3. Memory Efficiency: Eliminated the creation of large intermediate objects like 'distance_list' 
#    and 'class_count' dictionaries, significantly reducing the memory footprint and garbage collection overhead.
# 4. Optimized Preprocessing: Streamlined data loading and normalization using vectorized Pandas 
#    and NumPy operations rather than iterating through rows or columns manually.
# 5. Redundancy Removal: Removed the square root calculation in distance comparison since squared 
#    Euclidean distance is monotonic and yields the same nearest neighbors, saving unnecessary floating-point operations.