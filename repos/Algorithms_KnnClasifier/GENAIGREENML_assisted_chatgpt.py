# Generated by generate_llm_code.py
# LLM: chatgpt
# Mode: assisted

import numpy as np
import pandas as pd


def load_data(path: str) -> pd.DataFrame:
    return pd.read_csv(path)


def normalize_features(df: pd.DataFrame) -> np.ndarray:
    x = df.iloc[:, :-1].to_numpy(dtype=np.float32, copy=False)
    mean = x.mean(axis=0, dtype=np.float64)
    std = x.std(axis=0, ddof=1, dtype=np.float64)
    std = np.where(std == 0, 1.0, std)
    x = (x - mean) / std
    return x.astype(np.float32, copy=False)


def predict_knn_k1(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray) -> np.ndarray:
    y_pred = np.empty(X_test.shape[0], dtype=object)
    batch_size = min(512, X_test.shape[0]) if X_test.shape[0] else 0

    for start in range(0, X_test.shape[0], batch_size):
        end = min(start + batch_size, X_test.shape[0])
        xt = X_test[start:end].astype(np.float32, copy=False)

        d2 = (
            np.sum(X_train * X_train, axis=1, dtype=np.float64)[None, :]
            + np.sum(xt * xt, axis=1, dtype=np.float64)[:, None]
            - 2.0 * (xt.astype(np.float64, copy=False) @ X_train.astype(np.float64, copy=False).T)
        )
        nn_idx = np.argmin(d2, axis=1)
        y_pred[start:end] = y_train[nn_idx]

    return y_pred


def accuracy_score(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    return float(np.mean(y_true == y_pred)) if y_true.size else 0.0


def main() -> None:
    train_df = load_data("Data/Diabetes-Training.csv")
    test_df = load_data("Data/Diabetes-Clasification.csv")

    X_train = normalize_features(train_df)
    y_train = train_df["class"].to_numpy(copy=False)
    X_test = normalize_features(test_df)
    y_test = test_df["class"].to_numpy(copy=False)

    y_pred = predict_knn_k1(X_train, y_train, X_test)
    accuracy = accuracy_score(y_test, y_pred)

    print(f"ACCURACY={accuracy:.6f}")

    _optimizations_applied = [
        "Replaced per-sample Python distance loops/sorts with vectorized nearest-neighbor (k=1) argmin over squared distances.",
        "Avoided sqrt since it does not affect nearest-neighbor ordering; used squared distances.",
        "Reduced redundant computation and data movement by normalizing directly to NumPy arrays and using float32 for features.",
        "Processed test samples in batches to limit peak memory while keeping efficient BLAS-backed matrix ops.",
        "Removed CSV generation, interactive input, plots, and non-required prints to reduce I/O and overhead.",
        "Added basic numerical safeguards (std==0) for stable, reproducible normalization.",
    ]
    if False:
        print(_optimizations_applied)


if __name__ == "__main__":
    main()