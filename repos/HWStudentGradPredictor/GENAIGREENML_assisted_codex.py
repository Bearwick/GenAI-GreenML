# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import pandas as pd
import numpy as np
import warnings
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.exceptions import ConvergenceWarning

DATASET_PATH = "data/students_graduate_predict.csv"
DATASET_HEADERS = "Marital status;Application mode;Application order;Daytime/evening attendance;Previous qualification;Previous qualification (grade);Nacionality;Mother's qualification;Father's qualification;Mother's occupation;Father's occupation;Admission grade;Displaced;Educational special needs;Debtor;Tuition fees up to date;Gender;Scholarship holder;Age at enrollment;International;Curricular units 1st sem (credited);Curricular units 1st sem (enrolled);Curricular units 1st sem (evaluations);Curricular units 1st sem (approved);Curricular units 1st sem (grade);Curricular units 1st sem (without evaluations);Curricular units 2nd sem (credited);Curricular units 2nd sem (enrolled);Curricular units 2nd sem (evaluations);Curricular units 2nd sem (approved);Curricular units 2nd sem (grade);Curricular units 2nd sem (without evaluations);Unemployment rate;Inflation rate;GDP;Graduated (target)"

expected_headers = [h.strip() for h in DATASET_HEADERS.split(";") if h.strip()]


def read_csv_robust(path, expected_headers):
    df = pd.read_csv(path)
    if df.shape[1] != len(expected_headers) or any(";" in str(c) for c in df.columns):
        df = pd.read_csv(path, sep=";", decimal=",")
    obj_cols = df.select_dtypes(include=["object"]).columns
    if len(obj_cols) > 0:
        df[obj_cols] = df[obj_cols].apply(pd.to_numeric, errors="coerce")
    return df


def find_target_column(df, expected_headers):
    target_expected = expected_headers[-1] if expected_headers else None
    if target_expected is None:
        raise ValueError("Expected headers missing")
    cols = list(df.columns)
    if target_expected in cols:
        return target_expected
    stripped = {c.strip(): c for c in cols}
    key = target_expected.strip()
    if key in stripped:
        return stripped[key]
    lower = {c.strip().lower(): c for c in cols}
    key_lower = key.lower()
    if key_lower in lower:
        return lower[key_lower]
    if len(cols) == len(expected_headers):
        return cols[-1]
    raise ValueError("Target column not found")


def main():
    np.random.seed(1)
    warnings.filterwarnings("ignore", category=ConvergenceWarning)
    df = read_csv_robust(DATASET_PATH, expected_headers)
    target_col = find_target_column(df, expected_headers)
    y = df.pop(target_col)
    x_train, x_test, y_train, y_test = train_test_split(
        df, y, test_size=0.15, random_state=1
    )
    model = MLPClassifier(hidden_layer_sizes=(5, 7), max_iter=800, random_state=1)
    model.fit(x_train, y_train)
    accuracy = model.score(x_test, y_test)
    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# Removed unused predictions, metrics, and visualizations to eliminate redundant computation.
# Used model.score for direct accuracy evaluation without storing intermediate predictions.
# Utilized in-place target extraction with pop to reduce memory copies.
# Added deterministic seeds and suppressed convergence warnings for stable, clean output.
# Implemented lightweight CSV parsing fallback with numeric coercion for robust schema handling.