# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# --- Robust CSV Loading ---
try:
    df = pd.read_csv("data/students_graduate_predict.csv")
    if df.shape[1] < 3:
        raise ValueError("Too few columns, likely wrong separator")
except (ValueError, Exception):
    df = pd.read_csv("data/students_graduate_predict.csv", sep=';', decimal=',')

if df.shape[1] < 3:
    df = pd.read_csv("data/students_graduate_predict.csv", sep=';', decimal=',')

# --- Column Name Normalization ---
df.columns = df.columns.str.strip()
df.columns = df.columns.str.replace(r'\s+', ' ', regex=True)
df = df.loc[:, ~df.columns.str.startswith('Unnamed')]

# --- Identify Target ---
target_candidates = ['Graduated (target)', 'Target', 'target', 'Graduated']
target_col = None
for tc in target_candidates:
    matches = [c for c in df.columns if c.lower() == tc.lower()]
    if matches:
        target_col = matches[0]
        break

if target_col is None:
    # Fallback: use last column
    target_col = df.columns[-1]

# --- Coerce target ---
df[target_col] = pd.to_numeric(df[target_col], errors='coerce')
df = df.dropna(subset=[target_col])

y = df[target_col].astype(int)
X = df.drop(columns=[target_col])

# --- Check classification viability ---
n_classes = y.nunique()
assert n_classes >= 2, "Target must have at least 2 classes for classification"

# --- Feature type identification ---
feature_cols = list(X.columns)

# Coerce all columns to numeric where possible
for col in feature_cols:
    X[col] = pd.to_numeric(X[col], errors='coerce')

# Separate numeric and categorical features
numeric_cols = []
categorical_cols = []

for col in feature_cols:
    if X[col].dtype in [np.float64, np.int64, np.float32, np.int32]:
        n_unique = X[col].nunique()
        # Treat columns with very few unique values AND that are integer-like as categorical
        # But for efficiency, only if unique values are small
        if n_unique <= 10 and X[col].dropna().apply(lambda v: v == int(v)).all():
            categorical_cols.append(col)
        else:
            numeric_cols.append(col)
    else:
        categorical_cols.append(col)

# --- Handle NaN/inf ---
X = X.replace([np.inf, -np.inf], np.nan)

# For numeric cols, fill NaN with median
for col in numeric_cols:
    if X[col].isna().any():
        median_val = X[col].median()
        X[col] = X[col].fillna(median_val)

# For categorical cols, fill NaN with mode or 'missing'
for col in categorical_cols:
    if X[col].isna().any():
        mode_val = X[col].mode()
        if len(mode_val) > 0:
            X[col] = X[col].fillna(mode_val.iloc[0])
        else:
            X[col] = X[col].fillna(0)

# Convert categorical cols to string for OneHotEncoder
for col in categorical_cols:
    X[col] = X[col].astype(str)

assert len(X) > 0, "Dataset is empty after preprocessing"

# --- Build Preprocessing Pipeline ---
transformers = []
if numeric_cols: