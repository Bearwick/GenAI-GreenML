# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import pandas as pd
import numpy as np
import random
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
from nltk import PorterStemmer
from functools import lru_cache

SEED = 42
random.seed(SEED)
np.random.seed(SEED)

DATASET_HEADERS = ["Category", "Message"]

def read_csv_with_encoding(path, **kwargs):
    try:
        return pd.read_csv(path, **kwargs)
    except UnicodeDecodeError:
        return pd.read_csv(path, encoding="latin-1", **kwargs)

def load_dataset(path, expected_headers):
    df = read_csv_with_encoding(path)
    if df.shape[1] < len(expected_headers):
        df = read_csv_with_encoding(path, sep=";", decimal=",")
    return df

def resolve_columns(df, expected_headers):
    cols_lower = {str(c).strip().lower(): c for c in df.columns}
    resolved = [cols_lower.get(str(h).strip().lower()) for h in expected_headers]
    if all(resolved):
        return resolved
    return list(df.columns[:len(expected_headers)])

ps = PorterStemmer()

@lru_cache(maxsize=10000)
def stem_token(token):
    return ps.stem(token)

def convert(text):
    return " ".join(stem_token(t) for t in text.split())

def main():
    df = load_dataset("spam.csv", DATASET_HEADERS)
    cat_col, msg_col = resolve_columns(df, DATASET_HEADERS)
    categories = df[cat_col].fillna("").astype(str)
    messages_raw = df[msg_col].fillna("").astype(str)
    le = LabelEncoder()
    labels = le.fit_transform(categories)
    messages = [convert(m) for m in messages_raw]
    X_train, X_test, y_train, y_test = train_test_split(
        messages, labels, test_size=0.2, random_state=SEED
    )
    cv = CountVectorizer(stop_words="english")
    X_train_count = cv.fit_transform(X_train)
    X_test_count = cv.transform(X_test)
    model = MultinomialNB()
    model.fit(X_train_count, y_train)
    accuracy = accuracy_score(y_test, model.predict(X_test_count))
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# - Added cached stemming to avoid repeated token processing across messages.
# - Processed only required columns and avoided DataFrame mutation to reduce memory use.
# - Used list comprehensions and direct transformations to minimize intermediate data movement.
# - Added deterministic seeds and fixed split for reproducible training/evaluation.
# - Implemented robust CSV loading with fallback parsing to prevent reprocessing errors.