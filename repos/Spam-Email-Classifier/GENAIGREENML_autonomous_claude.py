# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score

# --- Robust CSV loading ---
try:
    df = pd.read_csv("spam.csv", encoding="utf-8")
    if df.shape[1] < 2:
        raise ValueError("Too few columns")
except Exception:
    try:
        df = pd.read_csv("spam.csv", sep=";", decimal=",", encoding="utf-8")
    except Exception:
        df = pd.read_csv("spam.csv", encoding="latin-1")

# If still too few columns, retry with latin-1 default sep
if df.shape[1] < 2:
    try:
        df = pd.read_csv("spam.csv", encoding="latin-1")
    except Exception:
        pass

# --- Column name normalization ---
df.columns = [str(c).strip().replace("  ", " ") for c in df.columns]
df = df[[c for c in df.columns if not c.startswith("Unnamed")]]

# Drop extra columns beyond the first two if they exist (spam.csv sometimes has extra empty cols)
if df.shape[1] > 2:
    df = df.iloc[:, :2]

# --- Identify target and text columns ---
cols = list(df.columns)
target_col = None
text_col = None

# Try to match expected schema
for c in cols:
    cl = c.lower()
    if cl in ("category", "label", "class", "v1", "target", "spam"):
        target_col = c
    if cl in ("message", "text", "sms", "v2", "content", "email"):
        text_col = c

# Fallback: first col = target, second col = text
if target_col is None:
    target_col = cols[0]
if text_col is None:
    text_col = cols[1] if len(cols) > 1 else cols[0]

# --- Preprocessing ---
df = df[[target_col, text_col]].dropna().reset_index(drop=True)
df[text_col] = df[text_col].astype(str)

# Encode target: map common spam labels to binary
label_map = {}
unique_labels = df[target_col].unique()
if len(unique_labels) == 2:
    # Detect which is spam vs ham
    for lab in unique_labels:
        lab_lower = str(lab).strip().lower()
        if lab_lower in ("spam", "1", "yes", "true"):
            label_map[lab] = 1
        else:
            label_map[lab] = 0
    if len(label_map) < len(unique_labels):
        # fallback: alphabetical, second = 1
        sorted_labels = sorted(unique_labels, key=str)
        label_map = {sorted_labels[0]: 0, sorted_labels[1]: 1}
    df["label"] = df[target_col].map(label_map)
else:
    # Generic label encoding
    from sklearn.preprocessing import LabelEncoder
    le = LabelEncoder()
    df["label"] = le.fit_transform(df[target_col].astype(str))

df = df.dropna(subset=["label"]).reset_index(drop=True)
df["label"] = df["label"].astype(int)

assert df.shape[0] > 0, "Dataset empty after preprocessing"
assert df["label"].nunique() >= 2, "Need at least 2 classes"

# --- Train/test split ---
X = df[text_col]
y = df["label"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

assert len(X_train) > 0 and