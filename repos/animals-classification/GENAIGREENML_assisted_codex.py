# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC

DATASET_HEADERS = "animal_name,hair,feathers,eggs,milk,airborne,aquatic,predator,toothed,backbone,breathes,venomous,fins,legs,tail,domestic,catsize,class_type"

def parsing_mismatch(df, headers):
    if df.shape[1] <= 1:
        return True
    expected = {h.strip().lower() for h in headers}
    actual = {str(c).strip().lower() for c in df.columns}
    return not expected.issubset(actual)

def read_csv_with_fallback(path, headers):
    df = pd.read_csv(path)
    if parsing_mismatch(df, headers):
        df_alt = pd.read_csv(path, sep=';', decimal=',')
        if not parsing_mismatch(df_alt, headers) or df_alt.shape[1] > df.shape[1]:
            df = df_alt
    return df

def prepare_features(df, headers):
    def norm(x):
        return str(x).strip().lower()
    expected = [h.strip() for h in headers]
    norm_expected = [norm(h) for h in expected]
    col_map = {norm(c): c for c in df.columns}
    present_expected = [col_map[n] for n in norm_expected if n in col_map]
    if len(present_expected) >= max(1, len(df.columns) - 1):
        base_cols = present_expected
    else:
        base_cols = list(df.columns)
    label_key = norm_expected[-1] if norm_expected else None
    name_key = norm_expected[0] if norm_expected else None
    label_col = col_map.get(label_key, base_cols[-1])
    name_col = col_map.get(name_key, base_cols[0])
    feature_cols = [c for c in base_cols if c not in (label_col, name_col)]
    X = df[feature_cols].to_numpy()
    y = df[label_col].to_numpy()
    return X, y

def main():
    np.random.seed(0)
    headers = DATASET_HEADERS.split(',')
    df = read_csv_with_fallback("zoo.csv", headers)
    X, y = prepare_features(df, headers)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)
    classifier = SVC()
    classifier.fit(X_train, y_train)
    y_pred = classifier.predict(X_test)
    accuracy = (y_pred == y_test).mean()
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# Removed unused predictions, scoring, and all visualization code to eliminate unnecessary computation and I/O.
# Replaced confusion-matrix-based accuracy with a vectorized equality mean to reduce overhead.
# Added robust CSV parsing fallback and schema alignment to avoid reprocessing and handle delimiter variations efficiently.
# Selected only required feature and label columns to minimize data movement and memory usage.
# Fixed random seed and deterministic split to ensure reproducible results.