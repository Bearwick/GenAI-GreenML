# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score
import warnings
warnings.filterwarnings("ignore")

# NSL-KDD column names based on the dataset specification
nsl_kdd_columns = [
    'duration', 'protocol_type', 'service', 'flag', 'src_bytes', 'dst_bytes',
    'land', 'wrong_fragment', 'urgent', 'hot', 'num_failed_logins', 'logged_in',
    'num_compromised', 'root_shell', 'su_attempted', 'num_root',
    'num_file_creations', 'num_shells', 'num_access_files', 'num_outbound_cmds',
    'is_host_login', 'is_guest_login', 'count', 'srv_count', 'serror_rate',
    'srv_serror_rate', 'rerror_rate', 'srv_rerror_rate', 'same_srv_rate',
    'diff_srv_rate', 'srv_diff_host_rate', 'dst_host_count', 'dst_host_srv_count',
    'dst_host_same_srv_rate', 'dst_host_diff_srv_rate', 'dst_host_same_src_port_rate',
    'dst_host_srv_diff_host_rate', 'dst_host_serror_rate', 'dst_host_srv_serror_rate',
    'dst_host_rerror_rate', 'dst_host_srv_rerror_rate', 'attack_type', 'difficulty_level'
]

# Robust CSV loading
df = None
try:
    df = pd.read_csv('data/raw/Train.txt', header=None)
    if df.shape[1] == 1:
        df = pd.read_csv('data/raw/Train.txt', header=None, sep=';', decimal=',')
except Exception:
    df = pd.read_csv('data/raw/Train.txt', header=None, sep=';', decimal=',')

# Assign column names if the number of columns matches or is close
if df.shape[1] == len(nsl_kdd_columns):
    df.columns = nsl_kdd_columns
elif df.shape[1] == len(nsl_kdd_columns) - 1:
    # Some versions of NSL-KDD don't have difficulty_level
    df.columns = nsl_kdd_columns[:-1]
else:
    # Fallback: use generic column names
    df.columns = [f'col_{i}' for i in range(df.shape[1])]

# Strip/normalize column names
df.columns = [str(c).strip().replace('  ', ' ') for c in df.columns]
df = df[[c for c in df.columns if not c.startswith('Unnamed')]]

# Identify target column
target_col = None
if 'attack_type' in df.columns:
    target_col = 'attack_type'
else:
    # Try to find a likely categorical target in the last few columns
    for c in reversed(df.columns):
        if df[c].dtype == object and df[c].nunique() > 1 and df[c].nunique() < 200:
            target_col = c
            break

if target_col is None:
    # Fallback: use last column
    target_col = df.columns[-1]

# Drop difficulty_level if present (it's metadata, not a feature)
if 'difficulty_level' in df.columns and target_col != 'difficulty_level':
    df = df.drop(columns=['difficulty_level'])

# Create binary target: normal vs attack
df['label'] = df[target_col].apply(lambda x: 0 if str(x).strip().lower() == 'normal' else 1)