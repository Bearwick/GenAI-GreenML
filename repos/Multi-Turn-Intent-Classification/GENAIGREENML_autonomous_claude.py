# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import json
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
import warnings
import os

warnings.filterwarnings("ignore")

# Load dataset
data_path = "data/input.json"

with open(data_path, "r", encoding="utf-8") as f:
    raw_data = json.load(f)

# Explore the structure of the JSON to determine schema
# The JSON could be a list of records or a dict with keys
if isinstance(raw_data, dict):
    # Check if it has a data key or similar
    possible_keys = list(raw_data.keys())
    # Try to find a list-valued key
    list_keys = [k for k in possible_keys if isinstance(raw_data[k], list)]
    if list_keys:
        records = raw_data[list_keys[0]]
    else:
        # Treat dict as a single record or columnar format
        try:
            df = pd.DataFrame(raw_data)
        except Exception:
            df = pd.DataFrame([raw_data])
        records = None
elif isinstance(raw_data, list):
    records = raw_data
else:
    records = [raw_data]

if records is not None:
    # Each record might have conversation turns and an intent/label
    # Inspect first record to understand structure
    sample = records[0] if len(records) > 0 else {}

    # Flatten conversations into text + label pairs
    texts = []
    labels = []

    for record in records:
        if not isinstance(record, dict):
            continue

        # Find text field: could be 'conversation', 'messages', 'turns', 'text', 'input', etc.
        text_content = None
        label_content = None

        rec_keys_lower = {k.lower().strip(): k for k in record.keys()}

        # Identify text fields
        text_candidates = ['conversation', 'conversations', 'messages', 'turns', 'text', 'input', 'query', 'utterance', 'content']
        for tc in text_candidates:
            if tc in rec_keys_lower:
                raw_val = record[rec_keys_lower[tc]]
                if isinstance(raw_val, list):
                    # List of turns - concatenate
                    turn_texts = []
                    for turn in raw_val:
                        if isinstance(turn, dict):
                            # Try to get message/text from turn
                            for msg_key in ['message', 'text', 'content', 'body', 'utterance']:
                                if msg_key in turn:
                                    turn_texts.append(str(turn[msg_key]))
                                    break
                            else:
                                turn_texts.append(str(turn))
                        else:
                            turn_texts.append(str(turn))
                    text_content = " ".join(turn_texts)
                elif isinstance(raw_val, str):
                    text_content = raw_val
                break

        # Identify label fields
        label_candidates = ['intent', 'label', 'class', 'category', 'target', 'prediction', 'expected_intent', 'true_intent']
        for lc in label_candidates:
            if lc in rec_keys_lower:
                label_content = record[rec_keys_lower[lc]]
                break

        # If no explicit label found, check for any string field that isn't the text
        if label_content is None:
            for k, v in record.items():
                if k.lower().strip() not in [tc for tc in text_candidates] and isinstance(v, str) and len(v) < 100:
                    label_content = v
                    break

        if text_content is None:
            # Fallback: concatenate all string values
            all_strings = [str(v) for v in