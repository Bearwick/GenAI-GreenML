# Generated by generate_llm_code.py
# LLM: codex
# Mode: assisted

import pandas as pd
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split

SEED = 42
DATASET_HEADERS = "age,gender,genre"

def parse_headers(header_str):
    return [h.strip() for h in header_str.split(",") if h.strip()]

EXPECTED_HEADERS = parse_headers(DATASET_HEADERS)

def read_csv_with_fallback(path, expected_headers):
    df = pd.read_csv(path)
    if len(df.columns) == 1 and len(expected_headers) > 1:
        try:
            df_alt = pd.read_csv(path, sep=";", decimal=",")
            if len(df_alt.columns) > 1:
                return df_alt
        except Exception:
            return df
    return df

def resolve_column(columns, name):
    name_lower = name.strip().lower()
    for col in columns:
        if col.strip().lower() == name_lower:
            return col
    return None

def prepare_data(path):
    df = read_csv_with_fallback(path, EXPECTED_HEADERS)
    target_col = resolve_column(df.columns, EXPECTED_HEADERS[-1]) if EXPECTED_HEADERS else None
    if target_col is None:
        target_col = df.columns[-1]
    feature_cols = [c for c in df.columns if c != target_col]
    X = df[feature_cols]
    y = df[target_col]
    return X, y

def train_and_evaluate(X, y):
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=SEED
    )
    model = DecisionTreeClassifier(random_state=SEED)
    model.fit(X_train, y_train)
    return model.score(X_test, y_test)

def main():
    X, y = prepare_data("music.csv")
    accuracy = train_and_evaluate(X, y)
    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    main()

# Optimization Summary
# Used fixed random_state values for deterministic splits and model training.
# Added a lightweight CSV parsing fallback to correct delimiter issues only when needed.
# Resolved the target column dynamically from provided headers and actual columns.
# Computed accuracy via model.score to avoid extra prediction storage and metric calls.
# Limited imports to required components to reduce overhead.