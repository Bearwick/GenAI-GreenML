# Generated by generate_llm_code.py
# LLM: claude
# Mode: assisted

import numpy as np
from scipy.spatial.distance import cdist

np.random.seed(42)

data = np.loadtxt('iris.csv', delimiter=',', dtype='object')
data = data[1:]

labels_str = data[:, -1]
labels = np.empty(len(labels_str), dtype=float)
labels[labels_str == 'setosa'] = 0
labels[labels_str == 'versicolor'] = 1
labels[labels_str == 'virginica'] = 2

features = data[:, 2:4].astype(float)

centroids = np.zeros((3, 2))
for i in range(3):
    centroids[i] = features[labels == i].mean(axis=0)

distances = cdist(features, centroids, metric='euclidean')
y_pred = np.argmin(distances, axis=1)
y_true = labels.astype(int)

accuracy = np.mean(y_pred == y_true)
print(f"ACCURACY={accuracy:.6f}")

# Optimization Summary
# Removed matplotlib imports and all plotting/saving of figures to eliminate unnecessary computation and I/O.
# Removed print statements and logging not related to final accuracy output.
# Removed redundant feature extraction (full 4-column features were only used for plots); directly load the 2 columns needed.
# Avoided creating intermediate label arrays by assigning directly into a pre-allocated float array.
# Removed the single-sample prediction code as it was illustrative only; the accuracy evaluation uses the same centroid classifier logic.
# Removed unnecessary reshape and single-sample cdist call since accuracy is computed over all samples.
# Set random seed for reproducibility even though this code is deterministic.
# Kept only essential computation: label encoding, centroid calculation, distance computation, accuracy.