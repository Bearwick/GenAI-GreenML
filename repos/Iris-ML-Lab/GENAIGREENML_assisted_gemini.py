# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import numpy as np
from scipy.spatial.distance import cdist

with open('iris.csv', 'r') as f:
    next(f)
    data = [line.strip().split(',') for line in f]

features = np.array([[float(r[2]), float(r[3])] for r in data], dtype=np.float32)
mapping = {'setosa': 0, 'versicolor': 1, 'virginica': 2}
y_true = np.array([mapping[r[4]] for r in data], dtype=np.int32)

centroids = np.array([features[y_true == i].mean(axis=0) for i in range(3)], dtype=np.float32)

sample = np.array([[3.1, 1.2]], dtype=np.float32)
_ = np.argmin(cdist(sample, centroids, metric='euclidean'), axis=1)

distances = cdist(features, centroids, metric='euclidean')
y_pred = np.argmin(distances, axis=1)
accuracy = np.mean(y_pred == y_true)

print(f"ACCURACY={accuracy:.6f}")

# OPTIMIZATION SUMMARY
# - Selective data loading: Only columns required for the task (petal features and species) are loaded, reducing I/O and memory overhead.
# - Optimized memory footprint: Used float32 and int32 instead of default float64 and object-type strings to lower RAM usage.
# - Fast parsing: Replaced heavy numpy.loadtxt with a lightweight list comprehension for CSV parsing, which is faster for small datasets.
# - Streamlined preprocessing: Replaced multiple mask-based assignments for label encoding with an efficient single-pass dictionary mapping.
# - Redundancy removal: Eliminated all visualization code, unnecessary prints, and intermediate feature slices to save CPU cycles.
# - Efficient computation: Centroids are computed in a single pass over classes, and distance calculations are vectorized via cdist.