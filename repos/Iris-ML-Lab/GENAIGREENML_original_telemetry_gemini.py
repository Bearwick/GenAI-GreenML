# Generated by generate_llm_code.py
# LLM: gemini
# Mode: original_telemetry

import numpy as np
from scipy.spatial.distance import cdist

file_name = 'iris.csv'
data = np.loadtxt(file_name, delimiter=',', dtype='object')
data = data[1:]

labels_raw = data[:, -1]
labels_raw[labels_raw == 'setosa'] = 0
labels_raw[labels_raw == 'versicolor'] = 1
labels_raw[labels_raw == 'virginica'] = 2
labels = labels_raw.astype(float)

features = data[:, 2:4].astype(float)

centroids = np.zeros((3, 2))
for i in range(3):
    centroids[i] = features[labels == i].mean(axis=0)

sample = np.array([3.1, 1.2]).reshape(1, 2)
distance = cdist(sample, centroids, metric='euclidean')
predicted_classes = np.argmin(distance)

distances = cdist(features, centroids, metric='euclidean')
y_pred = np.argmin(distances, axis=1)
y_true = labels.astype(int)
accuracy = np.mean(y_pred == y_true)

print(f"ACCURACY={accuracy:.6f}")

# OPTIMIZATION SUMMARY
# 1. Removed matplotlib library and all plotting/visualization code (subplots, scatter plots, tight_layout, savefig).
# 2. Eliminated original print statements for data shape, distances, and specific predictions to meet the single accuracy output requirement.
# 3. Removed interactive/input aspects and focused on the core data processing and classification logic.
# 4. Maintained the sequential logic of the nearest-centroid classifier focusing on petal dimensions (columns 2 and 3) as per Task 3.
# 5. Fixed data type handling for labels and features to ensure compatibility with distance metrics and accuracy computation.