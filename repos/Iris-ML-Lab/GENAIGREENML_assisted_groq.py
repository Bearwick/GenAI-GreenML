# Generated by generate_llm_code.py
# LLM: groq
# Mode: assisted

import numpy as np
from scipy.spatial.distance import cdist

# Load dataset
file_name = 'iris.csv'
with open(file_name, 'r') as f:
    header = f.readline().strip().split(',')
    data_lines = [line.strip().split(',') for line in f]

# Convert features and labels to numpy arrays
features = np.array([[float(v) for v in line[:4]] for line in data_lines])
labels_raw = np.array([line[4] for line in data_lines])

# Map string labels to numeric classes
unique_labels = np.unique(labels_raw)
label_to_int = {label: idx for idx, label in enumerate(unique_labels)}
labels = np.array([label_to_int[l] for l in labels_raw], dtype=int)

# Compute centroids for each class
centroids = np.array([features[labels == i].mean(axis=0) for i in range(len(unique_labels))])

# Predict classes by nearest centroid
distances = cdist(features, centroids)
predicted = np.argmin(distances, axis=1)

# Accuracy
accuracy = np.mean(predicted == labels)
print(f"ACCURACY={accuracy:.6f}")

# Optimizations applied:
# 1. Eliminated matplotlib and all plotting to remove rendering overhead.
# 2. Replaced generic file reading and data parsing with efficient list comprehensions
#    that directly convert to numpy arrays, avoiding intermediate object arrays.
# 3. Used a dictionary lookup for label mapping instead of multiple string comparisons.
# 4. Computed centroids with a list comprehension over boolean masks, removing explicit loops.
# 5. Calculated distances in a single cdist call, leveraging optimized C routines.
# 6. Removed all unnecessary prints and interactive inputs to reduce I/O.
# 7. The final output is concise and reproducible, using deterministic operations.