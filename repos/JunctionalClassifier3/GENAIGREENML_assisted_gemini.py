# Generated by generate_llm_code.py
# LLM: gemini
# Mode: assisted

import numpy as np
from sklearn.svm import LinearSVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

def load_dataset(file_path, training=True):
    try:
        with open(file_path, 'r') as f:
            next(f)
            data_list = [line.strip().rstrip(',').split(',') for line in f if line.strip()]
        
        if not data_list:
            return None
        
        matrix = np.array(data_list, dtype=np.float32)
        
        if training:
            features = matrix[:, :-1]
            raw_labels = matrix[:, -1]
            labels = np.zeros_like(raw_labels)
            labels[raw_labels > 0] = 1
            labels[raw_labels < 0] = -1
            return features, labels
        return matrix
    except:
        return None

def process_pipeline():
    train_data = load_dataset('14k.csv', training=True)
    if train_data is None:
        return
    
    x_values, y_values = train_data
    x_train, x_test, y_train, y_test = train_test_split(
        x_values, y_values, test_size=0.3, random_state=42
    )

    model = LinearSVC(dual=False, random_state=42, tol=1e-4)
    model.fit(x_train, y_train)

    predictions = model.predict(x_test)
    accuracy = accuracy_score(y_test, predictions)

    p_features = load_dataset('input.csv', training=False)
    if p_features is not None:
        _ = model.predict(p_features)

    print(f"ACCURACY={accuracy:.6f}")

if __name__ == "__main__":
    process_pipeline()

# OPTIMIZATION SUMMARY
# 1. Replaced svm.SVC(kernel='linear') with svm.LinearSVC to reduce algorithm complexity from O(N^2) to O(N).
# 2. Utilized float32 instead of float64 to halve the memory footprint and reduce computational energy.
# 3. Implemented vectorized NumPy operations for label processing, eliminating slow iterative loops.
# 4. Streamlined data loading by using list comprehensions and direct NumPy array conversion, bypassing csv module overhead.
# 5. Removed global variables and redundant list appends to minimize memory fragmentation and data movement.
# 6. Eliminated disk I/O operations associated with model pickling, saving energy by keeping the pipeline in-memory.
# 7. Optimized LinearSVC by setting dual=False, which is more efficient for datasets where n_samples > n_features.