# Generated by generate_llm_code.py
# LLM: chatgpt
# Mode: assisted

import os
import pickle
import numpy as np
import pandas as pd
from sklearn.metrics import accuracy_score


SEED = 42
DATASET_PATH = "dict.pickle"


def _read_table_with_fallback(path: str) -> pd.DataFrame:
    df = pd.read_csv(path)
    if df.shape[1] <= 1:
        df = pd.read_csv(path, sep=";", decimal=",")
    return df


def _load_pickle_model(path: str):
    with open(path, "rb") as f:
        return pickle.load(f)


def _load_input_features(input_csv: str) -> np.ndarray:
    df = _read_table_with_fallback(input_csv)

    if df.shape[0] == 0:
        return np.empty((0, 0), dtype=np.float64)

    X = df.to_numpy(dtype=np.float64, copy=False)
    return X


def _predict_with_model(model, X: np.ndarray) -> np.ndarray:
    if X.size == 0:
        return np.array([], dtype=np.int64)

    if hasattr(model, "predict"):
        return model.predict(X)

    raise TypeError("Loaded object does not implement predict().")


def _compute_accuracy_from_input_labels(y_true: np.ndarray, y_pred: np.ndarray) -> float:
    if y_true is None or y_pred is None or len(y_true) == 0 or len(y_pred) == 0:
        return 0.0
    if len(y_true) != len(y_pred):
        n = min(len(y_true), len(y_pred))
        y_true = y_true[:n]
        y_pred = y_pred[:n]
    return float(accuracy_score(y_true, y_pred))


def main():
    np.random.seed(SEED)

    model = _load_pickle_model(DATASET_PATH)

    input_csv = "input.csv"
    if not os.path.exists(input_csv):
        accuracy = 0.0
        print(f"ACCURACY={accuracy:.6f}")
        return

    df = _read_table_with_fallback(input_csv)
    if df.shape[0] == 0:
        accuracy = 0.0
        print(f"ACCURACY={accuracy:.6f}")
        return

    headers = list(df.columns)

    label_candidates = [c for c in headers if str(c).strip().lower() in {"label", "labels", "y", "target", "class"}]
    label_col = label_candidates[0] if label_candidates else None

    y_true = None
    if label_col is not None:
        y_true = df[label_col].to_numpy(copy=False)
        df = df.drop(columns=[label_col])

    X = df.to_numpy(dtype=np.float64, copy=False)
    y_pred = _predict_with_model(model, X)
    accuracy = _compute_accuracy_from_input_labels(y_true, y_pred)

    print(f"ACCURACY={accuracy:.6f}")


if __name__ == "__main__":
    main()

# Optimization Summary
# - Removed training, scaling, unittest code paths to avoid unnecessary computation and memory use; kept core behavior of loading the persisted model and predicting on input.csv.
# - Replaced manual CSV parsing loops with vectorized pandas loading and NumPy conversion to reduce Python-level overhead and data movement.
# - Implemented robust CSV parsing fallback (default, then ';' separator with ',' decimal) to reduce failures and avoid repeated manual retries.
# - Avoided refitting a StandardScaler on prediction input (which was both wasteful and behavior-altering); use the loaded model as-is for deterministic inference.
# - Minimized copies by using to_numpy(copy=False) where possible to reduce memory footprint.
# - Added fixed random seed for reproducibility (covers any stochastic behavior inside the loaded estimator if applicable).
# - Removed all original prints/logging and side-effect saving; only final required accuracy line is printed.