# Generated by generate_llm_code.py
# LLM: claude
# Mode: autonomous

import pickle
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.svm import LinearSVC
from sklearn.metrics import accuracy_score
import warnings
warnings.filterwarnings("ignore")

# Load the pickle file
with open("dict.pickle", "rb") as f:
    data = pickle.load(f, encoding="latin1")

# Inspect the loaded object and convert to a DataFrame
df = None

if isinstance(data, pd.DataFrame):
    df = data
elif isinstance(data, dict):
    # Try to build a DataFrame from the dict
    # Check if it's a dict of arrays/lists (column-oriented)
    try:
        df = pd.DataFrame(data)
    except Exception:
        # Maybe it's a nested structure; try to flatten
        # Check if values are dicts themselves
        first_key = list(data.keys())[0]
        first_val = data[first_key]
        if isinstance(first_val, dict):
            # dict of dicts -> records or similar
            df = pd.DataFrame.from_dict(data, orient="index")
        elif isinstance(first_val, np.ndarray) and first_val.ndim == 2:
            # Possibly features stored as 2D arrays with keys as labels
            frames = []
            for key, val in data.items():
                temp = pd.DataFrame(val)
                temp["_label_"] = key
                frames.append(temp)
            df = pd.concat(frames, ignore_index=True)
        else:
            # Last resort: try Series-like
            df = pd.DataFrame({"key": list(data.keys()), "value": list(data.values())})
elif isinstance(data, (list, np.ndarray)):
    df = pd.DataFrame(data)
else:
    # Try converting directly
    df = pd.DataFrame(data)

assert df is not None and len(df) > 0, "Failed to load data into a DataFrame"

# Clean column names
df.columns = [str(c).strip() for c in df.columns]
df.columns = [" ".join(c.split()) for c in df.columns]
# Drop unnamed columns
df = df[[c for c in df.columns if not c.lower().startswith("unnamed")]]

# Identify target column
# Based on README: classification into -1 (remodelling), 0 (mixed), 1 (inactive)
# Look for a column that looks like a label/target
target_col = None
candidate_target_names = ["label", "target", "class", "category", "y", "_label_", "Label", "Target", "Class"]

for name in candidate_target_names:
    if name in df.columns:
        target_col = name
        break

if target_col is None:
    # Heuristic: pick the last column if it has few unique values relative to dataset size
    last_col = df.columns[-1]
    if df[last_col].nunique() <= 20:
        target_col = last_col
    else:
        # Pick column with fewest unique values (likely categorical target)
        nuniques = df.nunique()
        # Filter to columns with at least 2 and at most 20 unique values
        candidates = nuniques[(nuniques >= 2) & (nuniques <= 20)]
        if len(candidates) > 0:
            target_col = candidates.idxmin()
        else:
            # Fallback: use last column
            target_col = df.columns[-1]

# Separate features and target
feature_cols = [c for c in df.columns if c != target_col]

# Coerce features to numeric where possible
for c in feature_cols:
    df[c] = pd.to_numeric(df[c], errors="coerce")

# Handle target: encode if needed
y = df[target_col].copy()
if y.dtype == object or isinstance(y.iloc[0], str):
    le = LabelEncoder()